[
{
	"uri": "https://QryptInc.github.io/eaas/appliance/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "Introduction The Quantum Entropy Appliance (QEA) is a server that comes equipped with Qrypt’s quantum random number generator cards. These cards continuously measure quantum phenomena to generate streams of truly random bytes.\nThe QEA can be installed on-prem, or in a data center, and it does not require any external network access. It exposes a REST API that can be called by clients in the same network to request arbitrary amounts of true random bytes.\nHow do we ensure true randomness? The entropy generated by the QEA is continuously tested using the NIST SP800-22 entropy source validation test suite. If any of the tests fail, then that entropy source is cut off until its output passes tests again.\nThe appliance also includes an extensive set of hardware health monitors that shut down the entropy source at the card level in the event of any hardware failure or anomaly.\nPerformance Due to the high overhead cost of making HTTP requests, the amount of entropy that can be retrieved from the API depends on how much entropy the client asks for with each request. In other words, it\u0026rsquo;s significantly faster to make 1 request for 512 keys than it is to make 512 requests for 1 key.\nMax API throughput:\n256 bit keys per request Requests per second 512 ~7,200 1 ~12,000 Max Entropy card output: ~1,500 Mb/s\nInstallation The QEA comes with Ubuntu Server v22.04 installed. Users will receive login credentials which they can use to perform any necessary admin tasks.\nThe QEA can be installed on-prem or in a datacenter rack. Once the appliance is connected to the network interface, the user must log in and configure its network interface (see the Ubuntu docs for a detailed guide on how to set up networking on Ubuntu Server).\nInteracting with the appliance The QEA listens for incoming requests on port 80.\nThe root path (“/”) returns a UI that displays various metrics, and health reports. This UI can also be used to download application log files for troubleshooting purposes.\nClient applications can request a configurable amount of entropy from the entropy API, which is served from the “/api/v1/” route. The complete spec for the API can be found below.\nAppliance Administration UI Upon opening the UI, you should see the following landing page:\nEach QRNG card installed on the appliance will have its own entry in the table, sorted by card ID.\nThe current state of the card can be determined by a quick glance at the \u0026ldquo;Status\u0026rdquo; column. Possible states are as follows:\nState Explanation Active The card is healthy and streaming entropy. Pending The card is in a temporary calibration state; this will resolve into either Active or Error. Error The card is reporting an error; the error message can be found in details section. Clicking on a card will expand the row and show more detail:\nIf the card is in an Error state, the number of errors and the error messages will be enumerated at the bottom of the details section.\nIf the card is Pending , a \u0026ldquo;Status Message\u0026rdquo; field will provide more information. This typically only happens on startup while the initial NIST test suite runs \u0026ndash; upon success, the card will move into an Active state and begin streaming entropy.\nNote that the badge in the \u0026ldquo;Status\u0026rdquo; section here is the same as in the card row entry.\nAt the bottom right of the UI, there is a link to download a compressed bundle of server logs:\nNote that this may take up to 30 seconds depending on the size of the logfiles, so do not navigate away from the page while the collection is in progress. Logfile processing is indicated by the presence of an animated spinner.\nTLS Configuration To enable TLS on the appliance, replace the following two files with your own public and private certs, respectively:\n/etc/ssl/certs/public.crt /etc/ssl/private/private.key Then, restart nginx for the new certs to take effect:\nsystemctl restart nginx You can test this new configuration by running:\nnginx -t Note that these operations must be done as sudo user.\nOpenAPI spec openapi: 3.0.0 info: title: Entropy API Schema description: Entropy API Schema version: 1.0.0 paths: /api/v1/entropy: post: summary: Get entropy description: Returns blocks of quantum entropy. requestBody: required: true content: application/json: schema: type: object properties: block_size: type: integer description: Size of each entropy block in bytes. format: byte minimum: 1 maximum: 1024 block_count: type: integer description: Number of entropy blocks. Defaults to 1. default: 1 minimum: 1 maximum: 512 responses: \u0026#39;200\u0026#39;: description: Entropy successfully generated. content: application/json: schema: type: object properties: entropy: type: array items: type: string format: byte description: Base64 encoded byte string representing the generated entropy. extensions: type: array items: type: object description: Optional array of JSON objects representing extensions. example: entropy: [\u0026#34;dWLmTxePnl5l9bnwb1qAAQ==\u0026#34;, \u0026#34;DnDqtrbysUoRwr9Meko+ug==\u0026#34;, \u0026#34;b//8fWTqpGWOFwbNNcQORQ==\u0026#34;, \u0026#34;9LhJWGYXQjt7x8/V1QBarw==\u0026#34;] extensions: [] \u0026#39;503\u0026#39;: description: Entropy capability source unavailable. /api/v1/capabilities: get: summary: Retrieve Entropy Capabilities description: This endpoint retrieves the capabilities of the entropy source. responses: \u0026#39;200\u0026#39;: description: Capabilities successfully retrieved. content: application/json: schema: type: object properties: entropy: type: object properties: min_block_size: type: integer description: Minimum block size in bytes. max_block_size: type: integer description: Maximum block size in bytes. min_block_count: type: integer description: Minimum block count. max_block_count: type: integer description: Maximum block count. entropy_types: type: array items: type: string description: Optional array of strings describing possible entropy source variations example: [\u0026#34;quantum\u0026#34;] extensions: type: array items: type: object description: Optional array of JSON objects representing extensions. healthtest: type: object properties: test_threshold: type: array items: type: object properties: test_type: type: string description: Test performed, e.g., nist_90b, dieharder, vendor_test1, etc. good: type: number format: float description: Test value for good quality entropy range, e.g., 0.95. warning: type: number format: float description: Test value for low quality entropy range, e.g., 0.90. error: type: number format: float description: Test value for bad quality entropy range, e.g., 0.85. extensions: type: array items: type: object description: Optional array of JSON objects representing extensions. Server Specs Dimensions 17\u0026quot; x 21.3\u0026quot; x 1.75\u0026quot; Processor One Intel® Xeon® Processor E-2300 (Rocket Lake) Product Family Supports CPU TDP up to 95W System Memory 2 channels DDR4 / 2 DPC UDIMM ECC Up to 3200 MT/s. Total 4 memory slots; up to 128GB Drive Bays 3.5\u0026quot; 1 (SATA) 2.5\u0026quot; 2 (1 x shared with 3.5\u0026quot;) M.2 2 x M.2(NGFF)/M-Key/22110 Expansion Slots 2 x PCIe Gen4 x8 slots 1 x PCIe Gen3 x8 slot (with x4 link) On-board Devices 6x SATA 6G ports (4x in miniSAS HD + 2x 7pin + 2x M.2) Aspeed AST2500 Advanced PCIe Graphics \u0026amp; Remote Management Processor Baseboard Management Controller Intelligent Platform Interface 2.0 (IPMI 2.0) iKVM, Media Redirection, IPMI over LAN, Serial over LAN Intel® I350 AM4/AM2 co-design to support 2/4 x GbE (SKU option) Realtek RTL8211EL for BMC dedicated management port 2D Video Graphic Adapter with PCIe bus interface Rear I/O LAN: 3 x GbE RJ45 (2 x shared, 1 x dedicated) USB: 2 x USB 3.0 Type A Graphic: Mini-display port (enabled with specified CPU) Serial Port: 1 x COM by 3.5mm audio jack Power Supply 300W 1+1 redundant power supply 80+ Gold System Cooling 3 x 40x56mm hot swap fans "
},
{
	"uri": "https://QryptInc.github.io/getting_started/",
	"title": "Getting Started",
	"tags": [],
	"description": "",
	"content": "Create a free Qrypt account First, create an account.\nNavigate to https://portal.qrypt.com and create a new account. Enter your email address and a strong password, then click the button to create your account. Check your email for the 4-digit account confirmation code and enter it on the website to confirm your account. When prompted, enter your first and last name. Generate an access token To use Qrypt\u0026rsquo;s Quantum Entropy or Key Generation, you need an access token.\nNavigate to the Tokens page. Assign a name to the token to help you distinguish between different tokens. Select \u0026lsquo;Entropy\u0026rsquo; and/or \u0026lsquo;Keygen to specify which service you will be using the token for. Select the expiration period. This determines when the token will expire and need to be replaced. Click the \u0026ldquo;Generate token\u0026rdquo; button. The generated token will be displayed. Copy the token using the “Copy” button and store it in a secure location. Important: This is the only time you will be able to view the access token. Be sure to copy and store it before closing this popup. Save the access token to a secure location. Your access token is used to make requests for entropy, a budgeted resource. It should be treated as secure data, very much like a password. Explore Qrypt\u0026rsquo;s Services With your access token, you can now use Qrypt\u0026rsquo;s services. Explore this documentation site to learn more about the different services we offer.\n"
},
{
	"uri": "https://QryptInc.github.io/eaas/",
	"title": "Quantum Entropy",
	"tags": [],
	"description": "",
	"content": "Using Qrypt\u0026rsquo;s Quantum Entropy Service Qrypt’s Entropy as a Service is a RESTful web service that allows you to generate random data (henceforth referred to as entropy or random) that is truly random—based on quantum-mechanical phenomena.\nThis service requires an access token. Follow the steps in Getting Started to obtain an access token.\nRelated Tools and Services RNG Tools: Integrating Qrypt\u0026rsquo;s Quantum Entropy service as a random source for system devices. Qseed: Integrating Qrypt\u0026rsquo;s Quantum Entropy service as a random source for PKCS#11 HSMs. Submit a request for entropy To get entropy from the service, you must submit an HTTP request to the REST API service, providing your access token and specifying the number of 1,024-byte blocks of entropy you would like to receive. You must also specify an access token—which identifies the user account requesting the data—in an HTTP “authorization” header. The data is returned in a JSON-encoded structure containing an array of base64-encoded strings, each of which decodes to a 1,024-byte block of entropy, as well as an integer specifying the number of strings in the array.\nTo ensure the privacy of your access token and the entropy data, all calls are made using an encrypted HTTPS connection.\nFollow these steps in your preferred tool or language of choice to request entropy (see subsequent sections Request and Response for details):\nSpecify your access token and the desired number of kibibytes (1,024 bytes) of entropy in a web request. Use the following URL: https://api-eus.qrypt.com/api/v1/quantum-entropy?size={kib_entropy}. Replace {kib_entropy} in the aforementioned URL with an integer indicating the number of kibibytes of entropy to return. Include an HTTP “Accept” header field with a value of “application/json”. Include an HTTP “Authorization” header with a value of “Bearer {access_token}”, where {access_token} is the access token obtained from the Qrypt portal. Submit the HTTP request using the HTTP GET method. If the HTTP request is successful, the JSON-formatted response will contain a structure containing two fields named “random” and “size”. The “random” field contains an array of base64-encoded strings (each of which—when decoded—contains 1,024 bytes of entropy). The “size” field contains the number of elements in the “random” field. The following sections provide more detailed explanations of the request and response.\nRequest The web service consists of one REST API call, which returns the entropy. The following table describes the properties of a valid REST API call.\nHTTP Verb GET URL https://api-eus.qrypt.com/api/v1/quantum-entropy?size={kib_entropy}\n{kib_entropy} is an integer that specifies the number of kibibytes (1,024 bytes) of entropy being requested. The minimum value is 1 and the maximum value is 512. If unspecified, the default value is one (1). Accept\n(header) \"application/json\" Authorization\n(header) \"Bearer {qrypt_access_token}\" {qrypt_access_token} is an access token generated in the Qrypt portal. Qrypt’s Quantum Entropy service is hosted in several locations worldwide. This allows you to access a server that is closer to the client for better reliability and response time. The following table (Table 2) indicates which subdomain to use in your URL to access the server located in the specified region.\nSubdomain Geographic location api-eus Eastern United States Response The response from the HTTP request will contain a numeric status code indicating whether or not the request succeeded and, if not, why. If successful, it will also return the entropy.\nStatus code Description 200 Success\nEntropy was successfully returned. 400 Bad request\nThe request was invalid (i.e., malformed or otherwise unacceptable). Please verify the format of the URL and the specified parameters. 401 Unauthorized\nThe access token is either invalid or has expired. 403 Limit reached\nThe account associated with the specified access token has already retrieved the maximum allotment of entropy allowed for the current period. Please contact a Qrypt representative to request a change to your limit. 429 Rate Limit reached\nThe access token used to pull random has exceeded the maximum number of requests (30) allowed for the designated time interval (10 seconds). Please wait and try again. 500 Internal server error\nThe Qrypt service has encountered an internal error. Please contact Qrypt support for further assistance. 503 Not enough supply\nQrypt’s supply of entropy is temporarily insufficient to fulfill the request. Please wait and try the request again. If a success status code of 200 was returned, the response contains a JSON-encoded structure containing an array size (which should match the kib_entropy value specified in the request) and an array of base64-encoded strings which, when decoded, contains 1,024 bytes of entropy.\nJSON Fields Description random An array of base64-encoded strings (as defined in RFC 4648 §4, Base 64 Encoding) . The length of the array is specified in the size field (below). Each string, when decoded, contains a 1,024-byte sequence of entropy. size The number of base64-encoded strings in the array returned in the random field (above). The following illustrates an example of JSON output as returned by a request for two 1,024-byte blocks of entropy:\n\u0026#34;random\u0026#34;: [ \u0026#34;\u0026lt;base64 encoding of 1,024 bytes of entropy\u0026gt;\u0026#34;, \u0026#34;\u0026lt;base64 encoding of 1,024 bytes of entropy\u0026gt;\u0026#34; ], \u0026#34;size\u0026#34;: 2 Examples The following examples demonstrate how to submit a request and display the returned entropy. In the following examples, {subdomain} should be replaced with the subdomain for a server in the geographic location you would like to use (see Table 2), {kib_entropy} should be replaced with an integer between 1 and 512, and {qrypt_access_token} should be replaced with an access token generated using your Qrypt account.\nCurl The following shows an example of how to submit a request for {kib_entropy} kibibytes of entropy using the {qrypt_access_token} via the curl command-line command. This command can be executed at a Windows or Unix command prompt.\ncurl https://{subdomain}.qrypt.com/api/v1/quantum-entropy?size={kib_entropy} -H \u0026#34;Authorization: Bearer {qrypt_access_token}\u0026#34; PowerShell The following shows an example of how to submit a request for {kib_entropy} kibibytes of data using the {qrypt_access_token} in PowerShell.\nSpecify entropy token, requested size of entropy, and subdomain\n[string] $accesstoken = \u0026#39;{qrypt_access_token}\u0026#39; [int] $kibData = {kib_entropy} [string] $sub = \u0026#39;{subdomain}\u0026#39; Define the request URL\n[string] $url = \u0026#34;https://$sub.qrypt.com/api/v1/quantum-entropy?size=$kibData\u0026#34; Define and submit the request\n$response = Invoke-RestMethod -Method Get -Uri $url -UseBasicParsing `-Headers @{ authorization = \u0026#34;Bearer $accesstoken\u0026#34; } ` -ContentType \u0026#39;application/json\u0026#39; Display the entropy bytes\nresponse.random | foreach { [Convert]::FromBase64String($_) } Python The following shows an example of how to submit a request for {kib_entropy} kibibytes of data using the {qrypt_access_token} in Python.\nYou may need to install the “requests” module before executing this example. For example, use the following command:\npython -m pip install requests import requests import base64 # Specify entropy token, requeststed size of entropy, and subdomain accesstoken = \u0026#39;{qrypt_access_token}\u0026#39; kibData = {kib_entropy} sub = \u0026#39;{subdomain}\u0026#39; # Define the request URL url = f\u0026#39;https://{sub}.qrypt.com/api/v1/quantum-entropy\u0026#39; # Define and submit the request headers = { \u0026#39;Authorization\u0026#39;: f\u0026#39;Bearer {accesstoken}\u0026#39; } params = { \u0026#39;size\u0026#39;: kibData } response = requests.get( url, headers=headers, params=params) # Display the entropy bytes for s in response.json()[\u0026#39;random\u0026#39;]: for b in base64.decodebytes( s.encode(\u0026#39;ascii\u0026#39;) ): print( f\u0026#39;{b}\u0026#39;) JavaScript The following shows an example of how to submit a request for {kib_entropy} kibibytes of data using the {qrypt_access_token} in JavaScript.\n\u0026#34;use strict\u0026#34;; // Specify entropy token, requested size of entropy, and subdomain let accessToken = \u0026#34;{qrypt_access_token}\u0026#34;; let kibData = { kib_entropy }; let sub = \u0026#34;{subdomain}\u0026#34;; // Define the request URL let url = `https://${sub}.qrypt.com/api/v1/quantum-entropy?size=${kibData}`; // Submit the request and process the response fetch(url, { method: \u0026#34;GET\u0026#34;, headers: { Accept: \u0026#34;application/json\u0026#34;, Authorization: \u0026#34;Bearer \u0026#34; + accessToken, }, }) .then((response) =\u0026gt; response.json()) .then(function (json) { // Display the entropy bytes json.random.forEach((b64) =\u0026gt; [...atob(b64)].forEach((c) =\u0026gt; console.log(c.charCodeAt(0))) ); }); "
},
{
	"uri": "https://QryptInc.github.io/eaas/rngd/",
	"title": "RNG Tools",
	"tags": [],
	"description": "",
	"content": "Using Qrypt\u0026rsquo;s Quantum Entropy in RNG Tools rng-tools is a utility that allows you to inject entropy from hardware sources, prngs, and http streams into system devices. Qrypt\u0026rsquo;s Quantum Entropy service is a random source option in rng-tools, allowing you to inject quantum entropy into system devices such as \u0026lsquo;/dev/random\u0026rsquo;, \u0026lsquo;/dev/urandom\u0026rsquo;, and user-defined nodes or files.\nThis service requires an access token. Follow the steps in Getting Started to obtain an access token.\nMore information about rng-tools can be found on the rng-tools Github and the rng-tools wiki page.\nInstallation To use Qrypt\u0026rsquo;s Quantum Entropy service in rng-tools, rng-tools must be installed and configured.\nClone the latest rng-tools master from GitHub.\ngit clone https://github.com/nhorman/rng-tools Install rng-tools dependencies. Additional packages may be required, depending on linux distro. The configure script below will name any missing packages it encounters.\nsudo apt install \\ make \\ libtool \\ libxml2-dev \\ libssl-dev \\ libcurl3-dev \\ libp11-dev \\ librtlsdr-dev \\ libusb-1.0-0-dev \\ libjansson-dev \\ libcap-dev Add --disable-dependency-tracking to the \u0026lsquo;./configure\u0026rsquo; command if needed.\n./autogen.sh ./configure make sudo make install Verify installation.\nwhich rngd Command Line Usage The resulting \u0026lsquo;rngd\u0026rsquo; executable can run directly to start either a daemon or a foreground process. By default, \u0026lsquo;rngd\u0026rsquo; will run as a background daemon and attempt to use the \u0026lsquo;hwrng\u0026rsquo;, \u0026rsquo;errand\u0026rsquo;, \u0026lsquo;pkcs11\u0026rsquo;, and \u0026lsquo;rtlsdr\u0026rsquo; random sources.\nTo run \u0026lsquo;rngd\u0026rsquo; using exclusively Qrypt\u0026rsquo;s Quantum Entropy, run the following command. This will run \u0026lsquo;rngd\u0026rsquo; as a foreground process with the Qrypt source enabled and all other entropy sources disabled. \u0026lsquo;rngd\u0026rsquo; will send its random to the /dev/random device.\nNote that \u0026lsquo;sudo\u0026rsquo; is needed in the command because \u0026lsquo;rngd\u0026rsquo; accesses the root folder.\nsudo rngd -f -x hwrng -x rdrand -x pkcs11 -x rtlsdr -n qrypt -O qrypt:tokenfile:\u0026lt;qrypt token path\u0026gt; Command line options: Option Description -f Run 'rngd' as a foreground process. If omitted, 'rngd' will run as a background daemon. -o \u0026lt;path\u0026gt; Device or file for the random number output. Defaults to '/dev/random'. -x \u0026lt;source\u0026gt; Disables the specified source. For example, '-x hwrng'. -n \u0026lt;source\u0026gt; Enables the specified source. For example, '-n qrypt'. -O \u0026lt;source\u0026gt;:\u0026lt;key\u0026gt;:\u0026lt;value\u0026gt; Sets a source specific configuration option. For example, '-O qrypt:tokenfile:/etc/rngd/qrypt.token'. Service Usage rng-tools comes with a \u0026lsquo;rngd.service\u0026rsquo; file for setting up a systemd service. To configure rngd to automatically start the Qrypt source on boot, follow these steps:\nSave your Qrypt api token to a system-accessible directory, such as \u0026lsquo;/etc/rngd/qrypt.token\u0026rsquo;. Then, edit \u0026lsquo;rngd.service\u0026rsquo; to add Qrypt arguments and options.\nNote that \u0026lsquo;sudo\u0026rsquo; is needed in the subsequent commands because \u0026lsquo;rngd\u0026rsquo; accesses the root folder.\n[Unit] Description=Hardware RNG Entropy Gatherer Daemon ConditionVirtualization=!container # The \u0026#39;-f\u0026#39; option is required for the systemd service \u0026#39;rngd\u0026#39; to work with Type=simple [Service] Type=simple ExecStart=\u0026lt;rngd install path\u0026gt; -f -x hwrng -x rdrand -x pkcs11 -x rtlsdr -n qrypt -O qrypt:tokenfile:\u0026lt;qrypt token path\u0026gt; SuccessExitStatus=66 [Install] WantedBy=multi-user.target Copy the \u0026lsquo;rngd\u0026rsquo; service to systemd.\nsudo cp rngd.service /etc/systemd/system/rngd.service sudo chmod 644 /etc/systemd/system/rngd.service Start the \u0026lsquo;rngd\u0026rsquo; service.\nsudo systemctl daemon-reload sudo systemctl start rngd Verify the \u0026lsquo;rngd\u0026rsquo; service is running properly.\nsudo systemctl status rngd Enable the \u0026lsquo;rngd\u0026rsquo; service for it to start on system boot.\nsudo systemctl enable rngd "
},
{
	"uri": "https://QryptInc.github.io/dqkd/",
	"title": "Digital Quantum Key Distribution (DQKD)  ",
	"tags": [],
	"description": "",
	"content": "What is DQKD? Alice is at one location (Site A), and Bob is at a different location (Site B). Each location has its own Key Management Entity (KME) that stores keys and makes them available for use by local clients.\nAlice wants to generate a symmetric encryption key and store it in the KME at Site A. She also wants to share that key with Bob and store it in the KME at Site B. It should then be possible to retrieve the key from either site, using the same key id.\nTraditional QKD systems use isolated fiber-optic or satellite based networks to send the key material between the sites.\nQrypt\u0026rsquo;s DQKD solution uses Qrypt\u0026rsquo;s BLAST protocol instead. The advantage of this protocol is that it makes it possible to exchange keys between sites securely over the public internet, without having to establish an isolated fiber-optic or satellite network.\nHow it works: A DQKD cluster consists of multiple sites, each of which has a KME that is identified by a unique KME ID.\nEach site has a server exposes the same API, which is an instance of the ETSI GS QKD 014 specification.\nThe cluster is secured using a single certificate trust chain. All endpoints on the cluster enforce mutual TLS, so all clients will need a client cert that is part of the same trust chain to call the endpoints on the respective sites.\nGenerating a key - example data flow Alice calls the enc_keys endpoint on Site A to generate a key that she wants to share with Bob: curl --cert My_Certs.p12 \\ \u0026#34;https://dqkd-eastus-1.qrypt.net/api/v1/keys/(Bob\u0026#39;s KME ID)/enc_keys\u0026#34; The DQKD server uses the BLAST protocol to generate a key and a new random key ID, and stores the key in the local KME\nThe key ID and metadata required to re-genrate that key is sent to site B.\nThe DQKD server at site B receives the metadata and uses it to re-generate the key.\nThe key is then stored and associated with the key ID in site B\u0026rsquo;s KME.\nAlice receives the key material along with the key ID in the response to her original request:\n{\u0026#34;keys\u0026#34;: [{\u0026#34;key\u0026#34;: \u0026#34;KEY_MATERIAL\u0026#34;,\u0026#34;key_ID\u0026#34;: \u0026#34;SOME_KEY_ID\u0026#34;}]} Alice sends Bob the key ID.\nBob calls the dec_keys endpoint on the DQKD server at site B to get a copy of the key:\ncurl --cert My_Cert.p12 \\ \u0026#34;https://dqkd-westus-1.qrypt.net/api/v1/keys/(Alice\u0026#39;s KME ID)/dec_keys\u0026#34; \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{\u0026#34;key_IDs\u0026#34;: [{\u0026#34;key_ID\u0026#34;: \u0026#34;SOME_KEY_ID\u0026#34;}]}\u0026#39; Bob receives the key material in the response: {\u0026#34;keys\u0026#34;: [{\u0026#34;key\u0026#34;: \u0026#34;KEY_MATERIAL\u0026#34;, \u0026#34;key_ID\u0026#34;: \u0026#34;SOME_KEY_ID\u0026#34;}]} Data flow - Illustrated "
},
{
	"uri": "https://QryptInc.github.io/",
	"title": "Home",
	"tags": [],
	"description": "",
	"content": "Qrypt Documentation Our documentation is written by developers for developers. The goal is to make it as easy as possible for developers to use Qrypt to secure applications and infrastructure.\nWe believe that documentation benefits from sharing and collaborative improvement. Qrypt documentation is available on Github pages and we invite anybody to make changes or to create issues when there is content that needs to be improved.\nIntegrating with Qrypt Below is a list of the products that Qrypt offers with links to their supporting documentation.\nQuantum Entropy Appliance (on-prem) Qrypt\u0026rsquo;s on-prem quantum entropy appliance is a server that is intentended for on-prem deployments. It exposes a REST API that clients can call to retrieve quantum entropy from the QRNG card installed on the server.\nQuantum Readiness Quantum readiness provides centralized deployment and management UI of all Qrypt products.\nPost quantum TLS proxy This post quantum TLS proxy allows for incoming TLS connections to use post quantum cryptography.\nQuantum Entropy as a Service Qrypt\u0026rsquo;s Quantum Entropy service measures quantum effects and converts those measurements into pure random numbers. The service leverages multiple Quantum Random Number Generators (QRNGs) developed in collaboration with national and international research labs to ensure the highest quality random.\nKey Generation Qrypt SDK includes client library SDKs, cloud-based REST services, command line clients and guidance to help integrate post-quantum security into your applications and services. You can add security features to your applications without being an expert in post-quantum cryptography.\nPortable OpenSSH with Qrypt This implementation of OpenSSH has been modified to provide additional security via the Qrypt Key Generation SDK. During key exchange negotiation, the Qrypt SDK will generate an additional quantum-secure secret that is added to the session key hash inputs.\n"
},
{
	"uri": "https://QryptInc.github.io/sdk/quickstarts/cpp/",
	"title": "Qrypt SDK Quickstarts",
	"tags": [],
	"description": "",
	"content": "The Qrypt SDK for C/C++ enables developers to add post-quantum security to their applications and services.\nCurrently we provide Distributed Key Generation.\nLibrary Compatibility The latest Qrypt SDK is built using the following compilers.\nPlatform Version Compiler CPU Ubuntu 22.04 gcc 11.4.0 x64 Sample Code Find the finalized code for these quickstarts on GitHub.\nPrerequisites A Qrypt Account. Create an account for free.\nQuickstarts Distributed key generation Generate One-Time Pads Encrypt and decrypt using generated One-Time Pads "
},
{
	"uri": "https://QryptInc.github.io/sdk/api/cpp/",
	"title": "Qrypt SDK",
	"tags": [],
	"description": "",
	"content": " "
},
{
	"uri": "https://QryptInc.github.io/sdk/overview/",
	"title": "Overview",
	"tags": [],
	"description": "",
	"content": "Developers need familiar tools based on modern development practices. We provide an SDK that can be easily integrated into applications and infrastructure to make them quantum-secure.\nThe Qrypt SDK includes client library SDKs, cloud-based REST services, command line clients and guidance to help integrate post-quantum security into your applications and services. You can add security features to your applications without being an expert in post-quantum cryptography.\nQrypt SDK for C/C++ Features Distributed key generation Library Compatibility The latest C++ SDK is built using the following compilers.\nPlatform Version Compiler CPU Ubuntu 22.04 gcc 11.4.0 x64 "
},
{
	"uri": "https://QryptInc.github.io/concepts/key-generation-architecture/",
	"title": "Key Generation Architecture",
	"tags": [],
	"description": "",
	"content": "Key distribution based on asymmetric algorithms is a weak link for cryptography.\nQrypt is the only company that enables encryption without distributing encryption keys – also basing them on trusted quantum random numbers.\nThe BLAST architecture enables generation of identical keys at multiple endpoints, so they are never distributed. Caches of random allow for sampling by multiple clients – with time and usage controls that trigger cache shredding. Client locally extracts keys from returned random – not even Qrypt can determine the keys. No dedicated channels or infrastructure required – unlike quantum key distribution (QKD). Walk-through\nClient A determines the key generation requirements: BLAST servers to be used, the sampling seeds, and extraction parameters​ Clients share the key generation requirements – seeds, extraction parameters​. Each client independently samples BLAST APIs, assembling identical blocks of random on each client.​ Clients locally extracts keys - resulting in identical encryption keys which were never distributed​. Attack scenarios required to compromise keys are extreme\nAttacker compromises the A to B channel and decrypts the key generation requirements before the server caches are shredded and can no longer be sampled. Even with a quantum computer the time to decrypt is too long Attacker compromises ALL aspects of the BLAST protocol, including TLS crypto​ Compromises ALL channels between a client and the N BLAST servers​ Compromises the A to B channel Defeat TLS cryptography used in A to B channel Full control of Client A or Client B "
},
{
	"uri": "https://QryptInc.github.io/sdk/",
	"title": "Key Generation",
	"tags": [],
	"description": "",
	"content": "Businesses need to protect against the future quantum threat, and never distribute encryption keys that can be intercepted. The Qrypt SDK allows you to generate identical keys at multiple endpoints.\nOverview Developers need familiar tools based on modern development practices. We provide an SDK that can be easily integrated into applications and infrastructure to make them quantum-secure.\nThe Qrypt SDK includes client library SDKs, cloud-based REST services, command line clients and guidance to help integrate post-quantum security into your applications and services. You can add security features to your applications without being an expert in post-quantum cryptography.\nThis service requires an access token. Follow the steps in Getting Started to obtain an access token.\nQuickstarts Demo applications built using Qrypt\u0026rsquo;s tools.\nAPI Reference Detailed API References for a growing list of plaforms.\nChangelogs Release notes and updates\nNvidia Quantum Secure Gateway Qrypt’s BLAST IPsec plug-in documentation\n"
},
{
	"uri": "https://QryptInc.github.io/eaas/nist/",
	"title": "NIST Entropy Quality Tests",
	"tags": [],
	"description": "",
	"content": "Using Qrypt\u0026rsquo;s NIST Entropy Quality Tests Qrypt’s NIST Entropy Quality Tests is a set of APIs that allows you to check the quality of Qrypt\u0026rsquo;s entropy using the NIST Statistical Test Suite. Tests are conducted every 10 minutes against Qrypt\u0026rsquo;s Quantum Entropy service. Accessing this service does not require a Qrypt account or access token.\nAbout NIST Entropy Quality Tests The NIST Entropy Quality Test suite uses the 15 statistical tests defined by the NIST Statistical Test Suite (STS). Each of these 15 tests is repeated over many samples. The APIs generate two test results:\nTotal number of individual passing tests: considered successful if a sufficient number of individual tests pass. The threshold varies based on the number of individual tests run and is based on an alpha value of 0.01. For example, 1000 individual tests requires a 98% pass rate to be considered successful. P-value uniformity for each of the 15 tests: considered successful if all 15 tests have uniformly distributed p-values. The tests are considered as succeeding overall if either of these criteria are met. This provides a metric for passing that is more robust to fluctuations than using either criterion alone. However, this standard does not catch certain randomness defects. For example, if the randomness was periodic with a period equal to the size used for batching, a sufficiently high portion of the tests might pass, but the P-values would not be uniform.\nNIST Entropy Quality Test Endpoints There are three endpoints for obtaining NIST entropy quality test results.\nNIST Logs: retrieves a specified number of recent test results Failing NIST Logs: retrieves a specified number of recent failing test results Failing NIST Random: retrieves random of recent failing tests NIST Logs This API contains the most recent NIST test results. To get NIST test results, you must submit an HTTP request to the API, optionally providing the number of results to view and whether they should be shown in a simplified format.\nMake a request to the following URL: https://nist.qrypt.com/api/v1/logs?num={num}\u0026amp;simple={simple}. Optionally replace {num} with the desired number of recent test results to show. Optionally replace {simple} with a true or false to specify if you want a simplified test result output. Request Parameters Request Fields Description num Optional. The number of logs to show. Can be set between 1 and 100, defaulting to 5. simple Optional. Format the logs in a summarized manner, only showing the 'tests_passed', 'time_of_completion' and 'time_of_completion_string' fields. Can be set to 'true' or 'false', defaulting to 'false'. Response Codes Status code Description 200 Success\nTest results were successfully retrieved. 400 Bad request\nThe request was invalid (i.e., malformed or otherwise unacceptable). Please verify the format of the URL and the specified parameters. 500 Internal server error\nThe Qrypt service has encountered an internal error. Please contact Qrypt support for further assistance. 503 Service Unavailable\nPlease wait and try the request again. JSON Response Fields For a successful 200 response, the response contains a JSON-encoded structure with an array of test results with the following fields in each array element. Note that the simplified logs only contain \u0026rsquo;tests_passed\u0026rsquo;, \u0026rsquo;time_of_completion\u0026rsquo; and \u0026rsquo;time_of_completion_string\u0026rsquo; fields.\nThere are two main groupings of tests. One is prefixed \u0026rsquo;nist\u0026rsquo; for the number of NIST STS tests that passed or failed, and the second is \u0026lsquo;uniformity\u0026rsquo; for the uniformity of each NIST STS test\u0026rsquo;s P-values.\nJSON Response Fields Description tests_passed If tests passed overall. This indicates either 'nist_all_passed' or 'uniformity_all_passed' is true. time_of_completion Unix timestamp of when the test was completed. time_of_completion_string String timestamp of when the test was completed. nist_all_passed If a sufficiently large percentage of NIST STS tests succeeded. nist_fails Number of NIST STS test failures. nist_passes Number of NIST STS test passes. nist_success_rate NIST STS test success rate. uniformity_all_passed If the P-values of all NIST STS tests are uniformly distributed. uniformity_fails Number of NIST STS tests with non-uniformly distributed P-values. uniformity_passes Number of NIST STS tests with uniformly distributed P-values. uniformity_success_rate NIST STS test uniformity success rate. The following illustrates an example of JSON output as returned by a request for a single log:\n[ { \u0026#34;nist_all_passed\u0026#34;: true, \u0026#34;nist_fails\u0026#34;: 86, \u0026#34;nist_passes\u0026#34;: 8742, \u0026#34;nist_success_rate\u0026#34;: 0.9855783640783642, \u0026#34;tests_passed\u0026#34;: true, \u0026#34;time_of_completion\u0026#34;: 1699551247.1653655, \u0026#34;time_of_completion_string\u0026#34;: \u0026#34;11/09/2023 12:34\u0026#34;, \u0026#34;uniformity_all_passed\u0026#34;: true, \u0026#34;uniformity_fails\u0026#34;: 0, \u0026#34;uniformity_passes\u0026#34;: 15, \u0026#34;uniformity_success_rate\u0026#34;: 1.0 } ] NIST Failed Test Logs This API contains the most recent failed NIST test results, where both the individual test rate and uniformity tests fail. To get failed NIST test results, you must submit an HTTP request to the API.\nMake a request to the following URL: https://nist.qrypt.com/api/v1/failing_logs?num={num}\u0026amp;simple={simple}\u0026amp;strict={strict}\u0026amp;include_random={include_random}\u0026amp;randsize={randsize} Optionally replace {num} with the number of recent test results to show. Optionally replace {simple} with \u0026rsquo;true\u0026rsquo; to output simplified logs. Optionally replace {strict} with \u0026lsquo;false\u0026rsquo; specify if you want to show logs that failed either the test rate or uniformity. Optionally replace {include_random} with \u0026rsquo;true\u0026rsquo; to see failed random. Only applicable if \u0026lsquo;strict\u0026rsquo; is \u0026rsquo;true\u0026rsquo;. Optionally replace {randsize} with the number of bits to show. Only applicable if \u0026lsquo;include_random\u0026rsquo; is set to \u0026rsquo;true\u0026rsquo;. Request Parameters Request Fields Description num Optional integer. The number of logs to show. Can be set between 1 and 100, defaulting to 5. simple Optional boolean. Format the logs in a condensed, summarized manner. Can be set to 'true' or 'false', defaulting to 'false'. strict Optional boolean. Require that the logs must fail uniformity and test rate to be considered failing. Can be set to 'true' or 'false', defaulting to 'true'. include_random Optional boolean. Determines if the random that failed the test will be included in the response. Only applicable when \"strict\" is true. Can be set to 'true' or 'false', defaulting to 'false'. randsize Optional integer. How many bits of random to include in the response. Can be set between 1 and 5242880 (640KiB), defaulting to 1024. Only applicable when \"include_random\" is true. Response Codes Status code Description 200 Success\nTest results were successfully retrieved. 400 Bad request\nThe request was invalid (i.e., malformed or otherwise unacceptable). Please verify the format of the URL and the specified parameters. 500 Internal server error\nThe Qrypt service has encountered an internal error. Please contact Qrypt support for further assistance. 503 Service Unavailable\nPlease wait and try the request again. JSON Response Fields The JSON response fields are identical to the NIST Logs API, except for the \u0026lsquo;random\u0026rsquo; field. The \u0026lsquo;random\u0026rsquo; field only appears if \u0026lsquo;include_random\u0026rsquo; is set to \u0026rsquo;true\u0026rsquo;.\nJSON Response Fields Description tests_passed If tests passed overall. This indicates either 'nist_all_passed' or 'uniformity_all_passed' is true. time_of_completion Unix timestamp of when the test was completed. time_of_completion_string String timestamp of when the test was completed. nist_all_passed If a sufficiently large percentage of NIST STS tests succeeded. nist_fails Number of NIST STS test failures. nist_passes Number of NIST STS test passes. nist_success_rate NIST STS test success rate. uniformity_all_passed If the P-values of all NIST STS tests are uniformly distributed. uniformity_fails Number of NIST STS tests with non-uniformly distributed P-values. uniformity_passes Number of NIST STS tests with uniformly distributed P-values. uniformity_success_rate NIST STS test uniformity success rate. random The tested random that failed. The following illustrates an example of JSON output as returned by a request for a single log:\n[ { \u0026#34;nist_all_passed\u0026#34;: true, \u0026#34;nist_fails\u0026#34;: 86, \u0026#34;nist_passes\u0026#34;: 8742, \u0026#34;nist_success_rate\u0026#34;: 0.9855783640783642, \u0026#34;tests_passed\u0026#34;: true, \u0026#34;time_of_completion\u0026#34;: 1699551247.1653655, \u0026#34;time_of_completion_string\u0026#34;: \u0026#34;11/09/2023 12:34\u0026#34;, \u0026#34;uniformity_all_passed\u0026#34;: true, \u0026#34;uniformity_fails\u0026#34;: 0, \u0026#34;uniformity_passes\u0026#34;: 15, \u0026#34;uniformity_success_rate\u0026#34;: 1.0, \u0026#34;random\u0026#34;: \u0026#34;111110100110010100001010100011\u0026#34; } ] NIST Failed Random This API contains the random of the most recent strictly failing NIST tests. To get the random of failed NIST test results, you must submit an HTTP request to the API.\nMake a request to the following URL: https://nist.qrypt.com/api/v1/failing_random?num={num}\u0026amp;randsize={randsize} Optionally replace {num} with the number of recent test results to show. Optionally replace {randsize} with \u0026rsquo;true\u0026rsquo; to output simplified logs. Request Parameters Request Fields Description num Optional integer. The number of logs to show. Can be set between 1 and 100, defaulting to 5. randsize Optional integer. Number of bits of random to include in the response. Can be set between 1 and 5242880, defaulting to 1024. Response Codes Status code Description 200 Success\nTest results were successfully retrieved. 400 Bad request\nThe request was invalid (i.e., malformed or otherwise unacceptable). Please verify the format of the URL and the specified parameters. 500 Internal server error\nThe Qrypt service has encountered an internal error. Please contact Qrypt support for further assistance. 503 Service Unavailable\nPlease wait and try the request again. JSON Response Fields JSON Response Fields Description random Failing bits of random. time_of_completion Unix timestamp of when the test was completed. createdAt Readable timestamp of when the test was completed. The following illustrates an example of JSON output as returned by a request for a single log:\n[ { \u0026#34;createdAt\u0026#34;: \u0026#34;Thu, 09 Nov 2023 12:54:06 GMT\u0026#34;, \u0026#34;random\u0026#34;: \u0026#34;111110100110010100001010100011\u0026#34;, \u0026#34;time_of_completion\u0026#34;: 1699534446.5982661 } ] "
},
{
	"uri": "https://QryptInc.github.io/quantumreadiness/",
	"title": "Quantum Readiness with Qrypt",
	"tags": [],
	"description": "",
	"content": "Overview Quantum Readiness is Qrypt\u0026rsquo;s single pane management console for all Qrypt products. Currently everything is containerized to support a wide range of machines and target environments.\nGeneral setup There are ports to set that allow frontend to backend communication. There are defaults set in the docker-compose.yaml.\nLocal There is a provided docker-compose.yaml. Run docker-compose up -d to bring up everything. The frontend should be available at http://localhost:8081/.\nCloud kubernetes Currently this is tested against the Azure cloud. This uses Microsoft Entra ID as the authentication system. WireGuard sidecar container are not covered here, but can be set up for further network security between external connections to this cluster. There will be an example kustomize yaml to follow. Below is a manual setup.\nCreate a Microsoft Entra ID to be used as authentication. Note the link, client id, client secret, and redirect url.\nDeploy a postgres database to be used in conjection with the backend.\nDeploy the backend proxy container. The following ports will need to be exposed to other pods 8080, 50051, 50052, 50053.\nDeploy the backend container. Make sure the set the DBCONNSTR environment variable with a connection string to the post res database.\nDeploy the web api container. Make sure to set the BACKEND_API environment variable to the backend proxy and the 50051 port. Set the EXPRESS_LISTEN_PORT environment variable to the port to listen for incoming requests.\nDeploy the auth container. Make sure to set the LOGOUT_REDIRECT_URL to the frontend container\u0026rsquo;s login URI. Set the REDIRECT_URL to the frontend container\u0026rsquo;s auth-redirect URI. Set the EXPRESS_LISTEN_PORT environment variable to the port to listen for incoming requests. Set AUTHORITY environment variable to the Entra ID link. Set CLIENT_ID environment variable to the Entra ID client id. Set the CLIENT_SECRET environment variable to the Entra ID client secret.\nDeploy the frontend container. The default serving port is 5173. Make sure to set the VITE_AUTH_API to the proxy container\u0026rsquo;s 50052 port. Make sure to set the VITE_BACKEND_API to the porxy container\u0026rsquo;s 50053 port.\nThe frontend should be available at the hostname set up for the cluster\u0026rsquo;s external IP and the exposed frontend container. This should bring you to a login screen which is hooked up to the Entra ID set up.\nPost quantum TLS proxy setup A WireGuard container is set up to run along side to allow for a symmetric key connection with the use of a preshared key. This will involve a standard WireGuard setup with generating keys and updating the WireGuard configuration to allow a connections. Please see our WireGuard sidecar container as an example.\nTo add a post quantum TLS proxy, go through the UI and make sure the add the host name/ip and port that the proxy is set up to listen to GRPC connections. The UI should then show the proxy.\nOn-Prem appliance setup The on-prem appliance has to be reachable from the network which quantum readiness is deployed on. To add an on-prem appliance, go to the \u0026ldquo;on-prem appliance\u0026rdquo; tab and click \u0026ldquo;Add an appliance\u0026rdquo;. Make sure to use the correct hostname or IP and port to connect to.\nDemo Please reach out to Qrypt for a demo or more information.\n"
},
{
	"uri": "https://QryptInc.github.io/sdk/quickstarts/",
	"title": "Quickstarts",
	"tags": [],
	"description": "",
	"content": "Use the Quickstarts to quickly get up and running with the Qrypt SDK.\nQrpyt SDK Quickstarts The Qrypt SDK for C/C++ enables developers to add post-quantum security to their applications and services.\n"
},
{
	"uri": "https://QryptInc.github.io/postquantumproxy/",
	"title": "Post quantum TLS proxy",
	"tags": [],
	"description": "",
	"content": "Overview This post quantum TLS proxy combines nginx, oqs OpenSSL, wireguard, and our quantum readiness orchestrator. This can be a stand alone proxy to serve content through traditional nginx configurations.\nSetup There are some exposed environment variables to set the default nginx algorithms. See below.\nDEFAULT_GROUPS: x25519:x448:kyber512:p256_kyber512:kyber768:p384_kyber768:kyber1024:p521_kyber1024 DEFAULT_SIG_ALGS: dilithium3:dilithium5 DEFAULT_CIPHERS: TLS_CHACHA20_POLY1305_SHA256 MIN_PROTOCOL: TLSv1.3 It also uses a config file at /opt/nginx/example.conf. This config controls the log level and quantum readiness connection.\nA container image is provided and it can be simply run with docker run -i -t --rm crypto-agility-orchestrator:latest sh to interact with.\nPlease reach out to Qrypt for a demo or more information.\n"
},
{
	"uri": "https://QryptInc.github.io/openssh/",
	"title": "Portable OpenSSH with Qrypt",
	"tags": [],
	"description": "",
	"content": "OpenSSH is a complete implementation of the SSH protocol (version 2) for secure remote login, command execution and file transfer. Our Qrypt modifications add a dash of quantum-secure.\nOverview Portable OpenSSH is a port of OpenBSD\u0026rsquo;s OpenSSH to most Unix-like operating systems, including Linux, OS X and Cygwin. It polyfills OpenBSD APIs that are not available elsewhere, adds sshd sandboxing for more operating systems and includes support for OS-native authentication and auditing (e.g. using PAM).\nThe Qrypt implementation of OpenSSH has been modified to provide additional security via the Qrypt Key Generation SDK. During key exchange (KEX) negotiation, the Qrypt SDK will generate an additional quantum-secure secret to be prepended to the session key hash inputs. Any conventional KEX algorithm can be enhanced by Qrypt security; a Qrypt-secured algorithm can be identified by the @qrypt.com suffix.\nCurrently availble Qrypt KEX algorithms:\ncurve25519-sha256@qrypt.com sntrup761x25519-sha512@qrypt.com The following sections will cover the two ways of obtaining Qrypt OpenSSH; by either downloading a Docker Compose file and using it to build a demo cluster, or building Portable OpenSSH from source and adding the Qrypt SDK.\nInstructions to create a demo cluster First, visit the Qrypt portal, make a free account, and generate a keygen token. Then, download our Docker Compose file here, and paste your token at the location labeled \u0026lt;PASTE-TOKEN-HERE\u0026gt;\nIn your terminal, run docker-compose up --build to build both the sshd server and the ssh/sftp client. The terminal will run the sshd-server container and print its debug outputs. To terminate the cluster, press Ctrl+C.\nWhen you\u0026rsquo;re finished with the demo, if you\u0026rsquo;d like to remove the cluster, run docker-compose down and all associated Docker containers and their network will be deleted.\nSSH Demo In a new terminal, run docker exec -it ssh-client bash to open an interactive terminal in the ssh-client container, which is equipped with both ssh and sftp. In this container:\nexport TOKEN=\u0026lt;PASTE-TOKEN-HERE\u0026gt; # Paste your token into the environment ssh -v -o QryptToken=$TOKEN sshuser@sshd-server.com # Log in to sshd-server.com as the user \u0026#34;sshuser\u0026#34; The default password for sshuser is \u0026ldquo;pass\u0026rdquo;. Verbose logging will print a line indicating the KEX algorithm used, and that algorithm\u0026rsquo;s name will end in @qrypt.com, showing that it is Qrypt-modified.\nTo show that we\u0026rsquo;re now logged into the server:\nbash # Change to a shell that shows the current user, the container name, and the current working directory exit # Exit Bash (when you\u0026#39;re done on the server) exit # Exit sshd-server SFTP Demo Assuming you are still in the ssh-client container:\necho \u0026#34;0123456789abcdef\u0026#34; \u0026gt; testfile # Create a file to push up to the server sftp -v -o QryptToken=$TOKEN sshuser@sshd-server.com # Open an sftp session The default password for sshuser is still \u0026ldquo;pass\u0026rdquo;. Verbose logging will print a line indicating the KEX algorithm used, and that algorithm\u0026rsquo;s name will end in @qrypt.com, showing that it is Qrypt-modified.\nTo send a file with sftp:\ncd /sftp/sshuser/upload # Navigate to the user\u0026#39;s upload directory ls # Show that the directory is empty put testfile # Upload the file ls # Show that the file is now in the upload directory To verify the test file, open a new terminal and navigate to the file on the server:\ndocker exec -it sshd-server bash # Open an interactive terminal the sshd server cd /sftp/sshuser/upload # Navigate to sshuser\u0026#39;s upload directory ls # Show the file in the directory cat testfile # Print the file contents (0123456789abcdef) (Optional) Rebuild OpenSSH to enable logging hex printouts of key material and metadata In either container:\ncd /root/openssh-portable sed -i \u0026#39;:a;N;$!ba;s/#define KEX_H\\n/#define KEX_H\\n\\n#define DEBUG_KEX\\n/g\u0026#39; kex.h # Set DEBUG_KEX flag make clean make make install To see changes in the server\u0026rsquo;s logging, it must be restarted after the above commands are run in its container. To see changes in the client\u0026rsquo;s on connection logging, you must reconnect after the above commands are run in its container.\nInstructions to build from source Follow the instructions found in the README, under the \u0026ldquo;Build with QryptSecurityC\u0026rdquo; header. This requires the Qrypt SDK which can be found on the Developer Portal.\n"
},
{
	"uri": "https://QryptInc.github.io/concepts/",
	"title": "Concepts",
	"tags": [],
	"description": "",
	"content": "Use the pages in this section to dig deeper into the post-quantum technologies Qrypt has to offer.\nKey Generation Architecture Architecture used to generate cryptographic keys for data encryption without distributing encryption keys.\nKey Entropy Size Understanding total entropy size using formula and examples\nOne-Time Pad (OTP) One-Time Pads are the only known information theoretically secure way to perform symmetric encryption. Qrypt is the first in the industry to offer a way to use OTP in a practical manner.\n"
},
{
	"uri": "https://QryptInc.github.io/eaas/pkcs11/",
	"title": "Qseed",
	"tags": [],
	"description": "",
	"content": "This page covers the Qseed application architecture that downloads quantum entropy from Qrypt\u0026rsquo;s entropy service and injects it into a PKCS#11 compliant HSM (Hardware Security Modules) as seed random.\nThis service requires an access token. Follow the steps in Getting Started to obtain an access token.\nTechnology Value Many of the available HSMs use non-quantum entropy sources. Fortunately, the PKCS#11 Cryptoki interface provides a C_SeedRandom function to inject entropy into a PKCS#11 compliant HSM. Developers can inject Qrypt\u0026rsquo;s quantum entropy into a HSM using the C_SeedRandom function. As a result, HSM keys can be pseudorandomly generated from quantum entropy.\nOverview There are four components to the architecture diagram above.\nQrypt Services: Qrypt\u0026rsquo;s entropy service that can provide quantum entropy via a REST API. Qseed Application: Application that periodically retrieves entropy from Qrypt\u0026rsquo;s entropy service and injects it into an HSM via a PKCS#11 Cryptoki interface (C_SeedRandom). Cryptoki Library: A library that the HSM vendor provides that implements the PKCS#11 Cryptoki interface for their device. HSM: Cryptographic hardware or software device. Installing Qseed Application The Qseed application and steps to install it can be found here.\nQseed FAQs How do I inject entropy into multiple HSM partitions?\nThe Qseed application can only inject entropy into a single partition. In order to seed multiple partitions, you will need to start multiple instances of the Qseed application.\nWhat is the recommended amount of entropy to inject into the HSM?\nThe Qseed application injects 48 bytes by default. This is recommended for Thales Network Luna 7 HSMs.\nWhy is more entropy downloaded than injected?\nQrypt\u0026rsquo;s entropy service supports entropy download at the granularity of KiBs. Extra downloaded entropy is discarded by the Qseed application.\nHow do I authenticate with the HSM partition using the Security Officer (SO) PIN?\nThe Qseed application only support Crypto User PINs. You will need to create a Crypto User PIN for the Qseed application.\nReferences More information about the PKCS#11 Cryptoki interface can be found at Oasis PKCS#11 Specification.\n"
},
{
	"uri": "https://QryptInc.github.io/concepts/entropy-projection/",
	"title": "Key Entropy Size",
	"tags": [],
	"description": "",
	"content": "Formula Total entropy size = (Number of keys) x (Entropy size per key) Key Size (bytes) Entropy Size Per Key (bytes) 16 20 32 (size of an AES-256 key) 40 64 80 256 290 1,024 (1 KiB) 1,140 (1.11 KiB) 10,240 (10 KiB) 11,380 (11.11 KiB) 102,400 (100 KiB) 113,780 (111.11 KiB) 1,048,576 (1 MiB) 1,165,090 (1.11 MiB) 10,485,760 (10 MiB) 11,650,850 (11.1 MiB) Example 1:\nTo generate (or to sync) 100 of AES-256 keys, the entropy size will be\n100 keys x 40 bytes/key = 4,000 bytes = 3.91 KiB Example 2:\nTo generate (or to sync) 100 of 256-byte OTP keys, the entropy size will be\n100 keys x 290 bytes/key = 29,000 bytes = 28.32 KiB Example 3:\nTo generate (or to sync) 100 of AES-256 keys and 200 of 256-byte OTP keys, the entropy size will be\n( 100 keys x 40 bytes/key ) + ( 200 keys x 290 bytes/key ) = 62,000 bytes = 60.55 KiB Example 4:\nAn entropy quota of 25 MiB allows you to generate (or to sync)\n( 20 MiB / 40 bytes/key ) = ( 20,971,152 bytes / 40 bytes/key ) = 65,536 keys of 32-bytes "
},
{
	"uri": "https://QryptInc.github.io/concepts/otp/",
	"title": "One-Time Pad (OTP)",
	"tags": [],
	"description": "",
	"content": "Our Technology Qrypt offers solutions to make One-Time Pads, the only known information theoretically secure symmetric encryption algorithm, finally practical in industry.\nWhat is classical cryptographic security? A cryptographic algorithm is considered secure, when the algorithm has been around for several years, and there is still no known method to “break” the algorithm with a classical computer.\nFor example, the widely used RSA algorithm has been around since 1977 with no significant progress made on a method to break it with a classical computer.\nWhat is post-quantum security? With the age of quantum computers being on the horizon, researchers have also explored methods to break cryptography using a quantum computer. Post-quantum cryptography means that after years of research, there is still no known method to “break” the cryptography, even given a quantum computer.\nFor example, RSA, would not satisfy post-quantum security because Shor’s algorithm, an attack using a quantum computer, was discovered to break RSA in 1994. On the other hand, AES-256 is considered post-quantum because no quantum attacks have been discovered since its publication in 1998.\nA One-Time Pad cipher is when a randomly chosen key, the same length of the plaintext, is XORed with the plaintext to produce the ciphertext. If the key is truly chosen randomly, all plaintexts of the given size are equally likely to have produced the ciphertext.\nWhat is information theoretic security? One-Time Pads have been mathematically proven to be information theoretically secure, meaning there is a mathematical proof that there exist no attacks (even with a computationally unbounded adversary) that can break a One-Time Pad. On the other hand, it is possible for a “post-quantum” algorithm to be broken, if in the future, someone were to discover a quantum attack on the algorithm.\nWhy isn’t everyone using One-Time Pads? One-Time Pads are only secure if the key is truly random, and only recent quantum technology has made truly random keys possible.\nIn addition, One-Time Pads are only secure if the keys are never reused. This means we need to share a newly randomly generated key, which is the same size of the plaintext, every time we want to send a new plaintext message. This reduces the security of the One-Time Pad down to the security of the key exchange algorithm.\nBLAST Distributed Qrypt offers a novel key generation solution, which offers everlasting security.\nHow secure are key exchange algorithms? Algorithms Level of Security Drawbacks RSA, Diffie Hellman, ECDH Classical security Not post-quantum Classic McEliece, CRYSTALS-KYBER, FrodoKEM Post-quantum security Not provably secure Slow/inefficient Quantum Key Distribution (QKD): BB84, E91, B92 Information theoretically secure (dependent on accuracy of hardware) Costly Range of communication is limited Tolerance for error in cryptographic security, however, is many order of magnitude smaller than in most physical engineering scenarios making it very difficult to validate Qrypt solution Everlasting security (explained below) Assumes the user has a secure channel with a user-configurable value g out of t Qrypt servers What is everlasting security? A protocol which achieves everlasting security guarantees that an encryption is information theoretically secure, given that the initial key exchange of the seed S is not broken within a time T which we can choose (i.e. an hour). This means that an hour after the two parties exchange an initial seed S, even a computationally unbounded adversary (with access to both classical and quantum computers) cannot break the encryption.\nLevels of Security Classical security that is vulnerable to quantum computers (i.e. RSA, ECDH)\nPost quantum security that has no known algorithm that quantum computers could run to break (i.e. FrodoKEM, Crystals-Kyber)\nFor levels 1 and 2, to break the encryption, an adversary would need to:\nHarvest data between Alice and Bob Break the key exchange 3a) Everlasting security which is provably secure against an unbounded adversary after phase 1 (while the server is still accepting decryption requests), where:\nthe seed key exchange has level 1 security in phase 1 we assume g out of T servers have secure, authenticated channels with the client (where these channels use TLS) 3b) Everlasting security which is provably secure against an unbounded adversary after phase 1 (while the server is still accepting decryption requests), where:\nthe seed key exchange has level 2 security in phase 1 we assume g out of T servers have secure, authenticated channels with the client (where these channels use TLS) 3c) Everlasting security which is provably secure against an unbounded adversary after phase 1 (while the server is still accepting decryption requests), where:\nthe seed has level 2 security in phase 1 we assume g out of T servers have secure, authenticated channels with the client (where these channels use post-quantum TLS) For levels 3a, 3b, and 3c, to break the encryption, an adversary would need to:\nHarvest data between Alice and Bob Harvest data from greater than T-g server links to Alice or Bob Break the key exchange of the seed Break the protocol for downloading random Information theoretic security that is provably secure against an unbounded adversary (which Qrypt only has the capability of doing with physical transfer of key material) "
},
{
	"uri": "https://QryptInc.github.io/sdk/nvidia/",
	"title": "NVIDIA Quantum Secure Gateway",
	"tags": [],
	"description": "",
	"content": "As the quantum era approaches, the need for cryptographic systems that can withstand the power of quantum computing becomes increasingly urgent. Current key exchange mechanisms like Elliptic Curve Diffie-Hellman (ECDH) are vulnerable to attacks from quantum computers, which can easily break these algorithms. To address this looming threat, it is critical to incorporate post-quantum key exchanges alongside traditional methods like (EC)DH to ensure that the resulting shared keys are secure against quantum-based attacks. RFC 9370 provides a framework for enhancing the Internet Key Exchange (IKEv2) protocol by enabling multiple successive key exchanges, including Post-Quantum Cryptography (PQC) techniques. This allows for the seamless integration of quantum-resistant algorithms with existing cryptographic protocols, ensuring compatibility while significantly strengthening security. The derived IKEv2 keys, fortified with these advanced techniques, are thus designed to be robust against the unprecedented capabilities of quantum computers.\nQrypt integrated the BLAST protocol and post-quantum algorithms in IKEv2 as additional key exchange methods, providing security against Harvest Now Decrypt Later (HNDL) attacks and future quantum attacks. This solution, is built as an IPsec plug-in that seamlessly combines existing classical and quantum-secure key exchanges with Qrypt’s BLAST protocol. The solution leverages the NVIDIA Bluefield-3 DPU’s hardware capability for secure network communication and optimized performance. Support for the Qrypt plug-in can be easily enabled by configuring the StrongSwan service running on the DPUs.\nQuick Recap of IKEv2 IKE_SA_INIT: Communication using IKE always begins with IKE_SA_INIT and IKE_AUTH exchanges. The first pair of messages (IKE_SA_INIT) negotiate cryptographic algorithms, exchange nonces, and do a Diffie-Hellman exchange. IKE_AUTH: The second pair of messages (IKE_AUTH) authenticate the previous messages, exchange identities and certificates, and establish the first Child SA. Parts of these messages are encrypted and integrity protected with keys established through the IKE_SA_INIT exchange, so the identities are hidden from eavesdroppers and all fields in all the messages are authenticated. CREATE_CHILD_SA: All messages following the initial exchange are cryptographically protected using the cryptographic algorithms and keys negotiated in the IKE_SA_INIT exchange. At this point in the negotiation, each party can generate a quantity called SKEYSEED, from which all keys are derived for the IKE SA. The messages that follow are encrypted and integrity protected in their entirety, with the exception of the message headers. RFC 9370 Summary: Multiple Key Exchanges in IKEv2 Overview RFC 9370 extends the Internet Key Exchange Version 2 (IKEv2) protocol to facilitate multiple key exchanges during the establishment of a Security Association (SA). This enhancement allows the computation of a final shared secret derived from multiple component key exchange secrets. Key points include:\nFinal Shared Secret: The shared secret is computed from all component key exchange secrets. Compatibility: If both peers do not support the new exchanges, the final shared secret will match the one specified in RFC 7296. Post-Quantum Security: If any component utilizes a quantum-safe algorithm, the resulting shared secret is also post-quantum secure. Negotiation Methods There are two primary methods to negotiate additional key exchange algorithms and establish quantum-secure IKE SAs: utilizing IKE_INTERMEDIATE exchanges during the initial Security Association (SA) setup or employing the IKE_FOLLOWUP_KE exchange for subsequent key exchanges. Below is a step-by-step breakdown of each method:\nOption 1: Using IKE_INTERMEDIATE Exchanges IKE_SA_INIT Negotiation: The key exchange method negotiated via Transform Type 4 (ECDH) takes place. The initiator includes up to seven newly defined transforms, that represent the extra key exchanges, in the SA payload within the IKE_SA_INIT message. The responder selects key exchange methods and returns their IDs in the IKE_SA_INIT response. Additional key exchanges are negotiated, leading to one or more IKE_INTERMEDIATE exchanges. IKE_INTERMEDIATE Exchanges: For each additional key exchange agreed upon, an IKE_INTERMEDIATE exchange is performed. The initiator sends key exchange data using the KEi(n) payload, protected with current keys SK_ei/SK_ai. The responder responds with the KEr(n) payload, also protected with SK_er/SK_ar. Both sides compute updated keying materials from the shared secrets generated during these exchanges. IKE_AUTH Exchange: After completing IKE_INTERMEDIATE exchanges, the initiator and responder perform the IKE_AUTH exchange, as per the IKEv2 specification. The shared keying material is completed as follows:\nSKEYSEED(n) = prf(SK_d(n-1), SK(n) | Ni | Nr) Where:\nSK(n) is the shared secret from the current exchange. Ni and Nr are nonces from the IKE_SA_INIT exchange. SK_d(n-1) is the previously generated SK_d (from IKE_SA_INIT or the last IKE_INTERMEDIATE exchange). Key materials (SK_d, SK_ai, SK_ar, SK_ei, SK_er, SK_pi, SK_pr) are derived from SKEYSEED(n) using the following formula:\n{SK_d(n) | SK_ai(n) | SK_ar(n) | SK_ei(n) | SK_er(n) | SK_pi(n) | SK_pr(n)} = prf+ (SKEYSEED(n), Ni | Nr | SPIi | SPIr) Both the initiator and responder use these updated keys in the next IKE_INTERMEDIATE or IKE_AUTH exchange.\n[Initiator] [Responder] | | | ------ IKE_SA_INIT ------\u0026gt; | | | |\u0026lt;------ IKE_SA_INIT ------\u0026gt; | | | |----- IKE_INTERMEDIATE ----\u0026gt;| | | |\u0026lt;----- IKE_INTERMEDIATE ---\u0026gt;| | | |------- IKE_AUTH ---------\u0026gt; | | | |\u0026lt;------- IKE_AUTH ---------\u0026gt;| Option 2: Using IKE_FOLLOWUP_KE Exchanges Initial IKE SA Setup: An IKE SA is established using the standard IKE_SA_INIT and IKE_AUTH exchanges. CREATE_CHILD_SA Exchange: The ECDH key exchange negotiated via Transform Type 4 takes place in the CREATE_CHILD_SA exchange, as per the IKEv2 specification [RFC7296]. The initiator proposes additional key exchanges via ADDKE(Additional Key Exchange) Transform Types in the CREATE_CHILD_SA payload. If the responder agrees, additional key exchanges occur in a series of IKE_FOLLOWUP_KE exchanges. IKE_FOLLOWUP_KE Exchanges: Similar to the first option, but here additional key exchanges occur directly after the CREATE_CHILD_SA exchange. Cryptographic parameters for ADDKE are exchanged. The exchange is protected with keys established through the CREATE_CHILD_SA exchange. After the exchanges, both peers compute updated keying materials as follows:\nFor IKE SA rekey:\nSKEYSEED = prf(SK_d, SK(0) | Ni | Nr | SK(1) | ... | SK(n)) SK_d is from the existing IKE SA. SK(0), Ni, and Nr are the shared key and nonces from the CREATE_CHILD_SA exchange. SK(1)\u0026hellip;SK(n) are shared keys from additional key exchanges. For Child SA creation or rekey:\nKEYMAT = prf+ (SK_d, SK(0) | Ni | Nr | SK(1) | ... | SK(n)) In both cases, SK_d comes from the existing IKE SA, and the keying material is derived from SK(0), Ni, Nr, and additional shared keys.\n[Initiator] [Responder] | | | ------ IKE_SA_INIT ------\u0026gt; | | | |\u0026lt;------ IKE_SA_INIT ------\u0026gt; | | | |------ IKE_AUTH ----------\u0026gt; | | | |\u0026lt;------ IKE_AUTH ----------\u0026gt;| | | |---- CREATE_CHILD_SA -----\u0026gt; | | | |\u0026lt;---- CREATE_CHILD_SA -----\u0026gt;| | | |--- IKE_FOLLOWUP_KE ------\u0026gt; | | | |\u0026lt;--- IKE_FOLLOWUP_KE ------\u0026gt;| Choosing the Method The choice between using IKE_INTERMEDIATE or IKE_FOLLOWUP_KE exchanges depends on the peers’ security policies. If the initial Child SA must be quantum secure, negotiating additional key exchanges through IKE_INTERMEDIATE exchanges may be preferable.\nBLAST Integration in IKEv2 Qrypt solution leverages RFC9370 specification that describes a method to perform multiple successive key exchanges in IKEv2. Qrypt keys are generated independently on each endpoint, however, to establish the same set of keys, parties must exchange the associated key metadata. Additional IKEv2 key exchanges are used to exchange the metadata.\nThe BLAST Protocol BLAST is the protocol used to eliminate key transmission and safeguard data against the Harvest Now Decrypt Later (HNDL) attack. The BLAST architecture enables generation of identical keys at multiple endpoints, so they are never distributed. Caches of random allow for sampling by multiple clients – with time and usage controls that trigger cache shredding. Client locally extracts keys from returned random – not even Qrypt can determine the keys. No dedicated channels or infrastructure required – unlike quantum key distribution (QKD). Walk-through Client A determines the key generation requirements: BLAST servers to be used, the sampling seeds, and extraction parameters Clients share the key generation requirements – seeds, extraction parameters. Each client independently samples BLAST APIs, assembling identical blocks of random on each client. Clients locally extracts keys - resulting in identical encryption keys which were never distributed. For more information see BLAST\nBLAST Key Exchange in IKEv2 Option 1: Using IKE_INTERMEDIATE IKE_SA_INIT messages are used to negotiate the BLAST key exchange and establish ECDH SSK (shared secret key) The initiator uses BLAST SDK to generate Qrypt key (QK) and the associated metadata The metadata is transmitted in the IKE_INTERMEDIATE message, encrypted using keys established in the previous step The responder uses BLAST SDK to generate the same QK from the received metadata QK and ECDH SSK are used to derive encryption and authentication keys as per RFC9370 Option 2: Using IKE_FOLLOWUP_KE An IKE SA is established using the standard IKE_SA_INIT and IKE_AUTH exchanges. The initiator proposes BLAST key exchange via ADDKE(Additional Key Exchange) Transform Types in the CREATE_CHILD_SA payload. The initiator uses BLAST SDK to generate Qrypt key (QK) and the associated metadata Exchange of the metadata occur directly after the CREATE_CHILD_SA exchange. The exchange is protected with keys established through the CREATE_CHILD_SA exchange. The responder uses BLAST SDK to generate the same QK from the received metadata QK and ECDH SSK are used to derive encryption and authentication keys as per RFC9370 NVIDIA Quantum Secure Gateway Architecture The process starts with IKEv2 negotiating Security Associations (SAs) between the initiator and responder, defining cryptographic parameters like algorithms and key lengths. An SA is uniquely identified by a triplet, which consists of the security parameter index (SPI), destination IP address, and security protocol identifier. An SPI is a 32-bit number. It is transmitted in the AH/ESP header. In IPsec, ESP uses these SAs to secure IP packets by referencing the Security Parameter Index (SPI) to identify the correct SA for each packet.\nAssociation of ESP with Security Associations (SAs) SA Establishment: During the IKEv2 negotiation, strongSwan establishes SAs between peers, assigning a unique SPI to each SA. This SPI serves as an identifier for the SA\u0026rsquo;s cryptographic parameters.\nPacket Processing: As ESP processes incoming packets, it examines the SPI in each packet\u0026rsquo;s header. Using this SPI, ESP retrieves the corresponding SA from the Security Association Database (SAD) to apply the correct cryptographic operations.\nHow ESP Identifies the Appropriate SA Receiving a Packet: When an IP packet arrives, ESP examines the SPI value in the packet\u0026rsquo;s header.\nSA Lookup: Using the SPI, ESP searches its Security Association Database (SAD) to find the corresponding SA that matches the SPI. The SAD contains entries for each active SA, indexed by their SPIs.\nApplying Security Parameters: Once the matching SA is identified, ESP retrieves the cryptographic parameters (such as encryption and authentication algorithms) associated with that SA. It then processes the packet accordingly to ensure data confidentiality and integrity.\nOpen vSwitch (OVS) OVS is used to facilitate the transfer of plaintext messages between the host and the DPU. In this context, OVS acts as a software-based network switch that manages network traffic, routing messages between the host’s CPU and the DPU without encryption.\nSetup East-West Overlay Encryption Setting up east-west overlay encryption can be done in two steps:\nConfigure the OVS (Open vSwitch):\nSetup the OVS bridge Configure the authentication method Run the script: Execute the following command, which runs the ovs-monitor-ipsec script and automates the configuration process:\nsystemctl start openvswitch-ipsec.service Configuring the OVS Set up OVS bridges in both hosts Start Open vSwitch. If your operating system is Ubuntu, run the following on both Arm_1 and Arm_2:\nservice openvswitch-switch start If your operating system is CentOS, run the following on both Arm_1 and Arm_2:\nservice openvswitch restart Start OVS IPsec service. Run the following on both Arm_1 and Arm_2:\nsystemctl start openvswitch-ipsec.service Set up OVS bridges in both DPUs. Run the following on both Arm_1 and Arm_2:\novs-vsctl add-br vxlan-br ovs-vsctl add-port ovs-br $PF_REP ovs-vsctl set Open_vSwitch . other_config:hw-offload=true Set up IPsec tunnel on the OVS bridge. Three authentication methods are possible. Select your preferred method and follow the steps relevant to it. Note that some authentication methods require you to create certificates (self-signed or certificate authority certificates).\nAuthentication Methods There are three authentication methods:\nUsing pre-shared key\nOn Arm_1, run:\novs-vsctl add-port vxlan-br tun -- \\ set interface tun type=vxlan \\ options:local_ip=$ip1 \\ options:remote_ip=$ip2 \\ options:key=100 \\ options:dst_port=4789 \\ options:psk= your pre-shared secret value On Arm_2, run:\novs-vsctl add-port vxlan-br tun -- \\ set interface tun type=vxlan \\ options:local_ip=$ip2 \\ options:remote_ip=$ip1 \\ options:key=100 \\ options:dst_port=4789\\ options:psk=your pre-shared secret value Pre-shared key (PSK) based authentication is easy to set up but less secure compared with other authentication methods. You should use it cautiously in production systems.\nUsing self-signed certificates\nGenerate self-signed certificate in both Arm_1and Arm_2. Then copy the certificate of Arm_1 to Arm_2 and the certificate of Arm_2 to Arm_1.\nOn Arm_1, run:\nGenerate self-signed certificates\novs-pki req -u host_1. ovs-pki self-sign host_1 ovs-vsctl set Open_vSwitch . other_config:certificate=/etc/swanctl/x509/host_1-cert.pem \\ other_config:private_key=/etc/swanctl/private/host_1-privkey.pem On Arm_2, run:\nGenerate self-signed certificates\novs-pki req -u host_2. ovs-pki self-sign host_2 ovs-vsctl set Open_vSwitch . other_config:certificate=/etc/swanctl/x509/host_2-cert.pem \\ other_config:private_key=/etc/swanctl/private/host_2-privkey.pem Copy the certificate of Arm_1 to Arm_2, and the certificate of Arm_2 to Arm_1. On each machine, move both host_1-privkey.pem and host_2-cert.pem to /etc/swanctl/x509/ if on Ubuntu, or /etc/strongswan/swanctl/x509/ if on CentOS. On each machine, move the local private key (host_1-privkey.pem on Arm_1 and host_2-privkey.pem on Arm_2) to /etc/swanctl/private if on Ubuntu, or /etc/strongswan/swanctl/private if on CentOS. Using CA-signed certificate:\nFirst you need to establish a public key infrastructure (PKI), generate certificate requests, and copy the certificate request of Arm_1 to Arm_2 and Arm_2 to Arm_1 . Sign the certificate requests with the CA key.\nOn Arm_1, run:\novs-pki init --force cp /var/lib/openvswitch/pki/controllerca/cacert.pem \u0026lt;path_to\u0026gt;/certsworkspace cd \u0026lt;path_to\u0026gt;/certsworkspace ovs-pki req -u host_1 ovs-pki sign host1 switch After running this code, you should have host_1-cert.pem, host_1-privkey.pem, and cacert.pm in the certsworkspace folder.\nOn Arm_2, run:\novs-pki init --force cp /var/lib/openvswitch/pki/controllerca/cacert.pem \u0026lt;path_to\u0026gt;/certsworkspace cd \u0026lt;path_to\u0026gt;/certsworkspace ovs-pki req -u host_2 ovs-pki sign host_2 switch After running this code, you should have host_2-cert.pem, host_2-privkey.pem, and cacert.pm in the certsworkspace folder.\nCopy the certificate of Arm_1 to Arm_2 and the certificate of Arm_2 to Arm_1. On each machine, move both host_1-privkey.pem and host_2-cert.pem to /etc/swanctl/x509/ if on Ubuntu, or /etc/strongswan/swanctl/x509/ if on CentOS. On each machine, move the local private key (host_1-privkey.pem if on Arm_1 and host_2-privkey.pem if on Arm_2) to /etc/swanctl/private if on Ubuntu, or /etc/strongswan/swanctl/private if on CentOS. On each machine, copy cacert.pem to the x509ca directory under /etc/swanctl/x509ca/ if on Ubuntu, or /etc/strongswan/swanctl/x509ca/ if on CentOS. Configure IPsec tunnel to use CA-signed certificate:\nOn Arm_1, run:\novs-vsctl set Open_vSwitch . \\ other_config:certificate=/etc/strongswan/swanctl/x509/host_1.pem \\ other_config:private_key=/etc/strongswan/swanctl/private/host_1-privkey.pem \\ other_config:ca_cert=/etc/strongswan/swanctl/x509ca/cacert.pem On Arm_2, run:\novs-vsctl set Open_vSwitch . \\ other_config:certificate=/etc/strongswan/swanctl/x509/host_2.pem \\ other_config:private_key=/etc/strongswan/swanctl/private/host_2-privkey.pem \\ other_config:ca_cert=/etc/strongswan/swanctl/x509ca/cacert.pem Execute a script After OVS is configured, run the following command:\nsystemctl start openvswitch-ipsec.service This command automatically runs the ovs-monitor-ipsec script and generates the swanctl.conf file. This command also runs the strongSwan IPsec service.\nScript Parameters Note that critical information such as key exchange and authentication algorithms to be used for IKE SA and ESP SA are passed in the ovs-monitor-ipsec script to later generate a swanctl.conf file. Ensure that the script contains all the key exchange algorithms to be used for IKE SA establishment. For instance, parameters ke1_kyber3-ke2_blast passed in the ovs-monitor-ipsec script\nsudo sed -i \u0026#39;s/aes256gcm16-modp2048-esn/aes256gcm16-modp2048-ke1_kyber3-ke2_blast-esn/g\u0026#39; /usr/share/openvswitch/scripts/ovs-monitor-ipsec will result in swanctl.conf parameters:\nesp_proposals = aes128gcm128-x25519-ke1_kyber3-ke2_blast strongSwan configuration file Here’s a basic structure for the swanctl.conf file that includes necessary parameters for both ends of the connection (referred to as Left (BFL) and Right (BFR)):\nconnections { BFL-BFR { local_addrs = 192.168.50.1 // Replace with your local IP remote_addrs = 192.168.50.2 // Replace with your remote IP local { auth = psk // Use pre-shared key authentication id = host1 // Identifier for local machine } remote { auth = psk // Use pre-shared key authentication id = host2 // Identifier for remote machine } children { bf { local_ts = 192.168.50.1/24 [udp/4789] // Local traffic selectors remote_ts = 192.168.50.2/24 [udp/4789] // Remote traffic selectors esp_proposals = aes128gcm128-x25519 // Encryption proposals should include additional key exchanges mode = transport // Use transport mode policies_fwd_out = yes // Forward output policies hw_offload = full // Enable hardware offload } } version = 2 // Specify version mobike = no / Mobile IP not used reauth_time = 0 // Re-authentication time proposals = aes128-sha256-x25519 // IKE proposals } } If using pre-shared key (PSK) for authentication, add a section to the swanctl.conf file:\nsecrets { ike-BF { id-host1 = host1 // Identifier for Left Arm id-host2 = host2 // Identifier for Right Arm secret = 0sv+NkxY9LLZvwj4qCC2o/gGrWDF2d21jL // Replace with your actual secret } } Ensure that all the data needed to generate the swanctl.conf file is correctly passed in the ovs-monitor-ipsec script.\nFor more information see NVIDIA DOCA East-West Overlay Encryption Application\nBuild strongSwan with liboqs and Qrypt\u0026rsquo;s BLAST plugin Create a directory to clone the repos into mkdir qrypt cd qrypt Clone and build liboqs sudo apt -y install astyle cmake gcc ninja-build libssl-dev python3-pytest python3-pytest-xdist unzip xsltproc doxygen graphviz python3-yaml valgrind git clone -b main \u0026lt;https://github.com/open-quantum-safe/liboqs.git\u0026gt; cd liboqs mkdir build cd build cmake -GNinja -DOQS_USE_OPENSSL=ON -DBUILD_SHARED_LIBS=ON -DCMAKE_INSTALL_PREFIX=/usr \\\\ -DCMAKE_BUILD_TYPE=Release -DOQS_BUILD_ONLY_LIB=ON .. ninja sudo ninja install cd ../../ Clone the strongSwan repo git clone \u0026lt;https://github.com/QryptInc/strongswan.git\u0026gt; cd strongswan git checkout BF-6.0.0beta4-qrypt-plugins Edit the plugin conf files Create a free account at https://docs.qrypt.com/getting_started/ This will enable you to generate JSON web tokens (JWT) that you\u0026rsquo;ll need to add to the conf files.\nstrongswan/src/libstrongswan/plugins/quantum_entropy/quantum-entropy.conf:\nquantum_entropy { // Entropy API FQDN fqdn = api-eus.qrypt.com // Entropy API JWT jwt = \u0026lt;PASTE-TOKEN-HERE\u0026gt; // File to read local random bytes for xor with downloaded entropy random = /dev/random // Whether to load the plugin. Can also be an integer to increase the // priority of this plugin. load = yes } strongswan/src/libstrongswan/plugins/blast/blast.conf:\nblast { jwt = \u0026lt;PASTE-TOKEN-HERE\u0026gt; load = yes } Build strongSwan Building a strongSwan 6.X tag will include support for RFC 9370 which will allow for hybrid key exchanges including PQC and BLAST.\nsudo apt-get -y install pkg-config shtool autoconf gperf bison build-essential pkg-config m4 libtool libgmp3-dev automake autoconf gettext perl flex libsystemd-dev libjansson-dev curl libcurl4-openssl-dev ./autogen.sh ./configure --enable-openssl --disable-random --prefix=/usr/local --sysconfdir=/etc --enable-systemd --enable-oqs --enable-curl make sudo make install cd .. Build Qrypt\u0026rsquo;s BLAST plugin Retrieve Qrypt\u0026rsquo;s SDK library from the Qrypt Portal from \u0026ldquo;Products-\u0026gt;Qrypt SDK\u0026rdquo;. Copy the libQryptSecurity.so and libQryptSecurityC.so libraries to src/libstrongswan/plugins/blast/. Then, proceed with the following instructions.\ncd src/libstrongswan/plugins/blast/ sudo make install-deps sudo ldconfig make SWANDIR=../../../.. sudo make install PLUGINCONF=/etc/strongswan.d/charon/ cd ../../../.. Start and stop service sudo systemctl daemon-reload sudo systemctl stop strongswan.service sudo systemctl start strongswan.service sudo systemctl status strongswan.service "
},
{
	"uri": "https://QryptInc.github.io/sdk/api/",
	"title": "API Reference",
	"tags": [],
	"description": "",
	"content": "Detailed API References for a growing list of plaforms.\nQrypt SDK "
},
{
	"uri": "https://QryptInc.github.io/faqs/",
	"title": "Frequently Asked Questions",
	"tags": [],
	"description": "",
	"content": "What do I do if I forget my password?\nQrypt does not have access to your password, but you can place a request to change your password.\nNavigate to the portal at https://portal.qrypt.com and click the “Forgot password?” link. Enter the email address associated with your account and click the “Send me the link” button. Check your email for a message with further instructions. How do I change my password?\nNavigate to the portal at https://portal.qrypt.com and login to your account. Click the account icon (top-right corner) and select “Account settings.” Click the “Change password” link. Enter your original password, enter a new password, and click the “Change password” button. What should I do with my access token?\nYour access token is the mechanism by which your account will be charged for entropy data, and as such, it should be treated as secure and secret information (much as you would treat a password).\nI lost or forgot to save my access token. How can I retrieve it?\nTo increase security, Qrypt only displays access tokens when they are first generated. If you have lost your token, you can contact Qrypt sales support at support@qrypt.com or generate a new one.\nWhat happens if my access token expires?\nAfter an access token expires, any quantum entropy service requests using that token will return an error code of 401. After an access token expires, any key generation SDK calls using that token will thow a CannotDownload exception. You will need to generate a new token and use it for future quantum entropy requests or key generation SDK calls.\nWhat happens if I have exceeded my monthly entropy quota?\nOnce the monthly entropy quota has been reached, quantum entropy service requests will return an error code of 403. Once the monthly entropy quota has been reached, key generation SDK calls will thow a CannotDownload exception. Please contact Qrypt sales support at support@qrypt.com.\nI need more entropy bytes per month than my current quota provides.\nTo increase your quota of entropy bytes you can generate per month, either upgrade from your free account to a paid account or contact Qrypt sales support at support@qrypt.com.\nWhen does my entropy quota reset?\nYour quota is reset monthly on the day of the month on which you opened the account.\nHow is quantum entropy different from rand, urand, grand, and other pseudorandom number generators?\nThe generation of random and pseudorandom numbers is too large a topic to be covered thoroughly here, but the concepts are quite simple. There exist quantum behaviors that are completely random and unpredictable according to the laws of physics. By using a device called a homodyne laser interferometer—which can detect such quantum behaviors—Qrypt can generate and provide sequences of truly random data.\nHow can I delete my Qrypt account?\nWe do not currently support online cancellation of accounts. Please contact Qrypt Sales Support at support@qrypt.com to delete your account.\n"
},
{
	"uri": "https://QryptInc.github.io/sdk/changelogs/",
	"title": "Changelogs",
	"tags": [],
	"description": "",
	"content": "Versions SDK v0.11.23 SDK v0.11.22 SDK v0.11.19 SDK v0.11.14 SDK v0.11.6 SDK v0.10.2 SDK v0.9.2 SDK v0.8.6 SDK v0.7.10 SDK v0.7.4 SDK v0.6.4 SDK v0.11.23 Notable Changes:\nAdded C interface and library SDK v0.11.22 Notable Changes:\nUpdating internal testing interfaces SDK v0.11.19 Notable Changes:\nUpgrading SDK build from Ubuntu 20.04 to Ubuntu 22.04 Upgrading SDK build from gcc 9.4.0 to gcc 11.4.0 SDK v0.11.14 Notable Changes:\nUpgrading OpenSSL dependency to 3.1.4 and libcurl dependency to 8.2.1 Fixing verification for corrupted metadata SDK v0.11.6 Notable Changes:\nThis release contains breaking API changes\nUpdating metadata schema (no longer compatible with previous versions) Adding public HTTPS client interface Upgrading to C++ 17 Upgrading OpenSSL dependency to 1.1.1v and flatbuffers dependency to 23.5.26 SDK v0.10.2 Notable Changes:\nThis release contains breaking API changes\nSimplify keygen genInit API to use key sizes and remove key mode Add customizable TTL in genInit Upgrade OpenSSL dependency to 1.1.1t and libcurl dependency to 8.0.0 SDK v0.9.2 Notable Changes:\nChange backend to use sequential sampling and seedless extraction Change smallest allowed key size to 1 byte Simplify logging API SDK v0.8.6 Notable Changes:\nMove exceptions to QryptSecurity namespace Rename log level enumerations Update metadata schema Reduce library binary size SDK v0.7.10 Notable Changes:\nAdd chunk multi-threading for genInit and genSync Increase maximum supported OTP size to 10MB SDK v0.7.4 Notable Changes:\nImprove sample retry logic for genInit and genSync Increase maximum supported OTP size to 512KB Update metadata schema SDK v0.6.4 Notable Changes:\nInitial baseline of the SDK "
},
{
	"uri": "https://QryptInc.github.io/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://QryptInc.github.io/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]
[
{
	"uri": "https://QryptInc.github.io/eaas/",
	"title": "Entropy as a Service",
	"tags": [],
	"description": "",
	"content": "Using Qrypt Entropy as a Service Qrypt’s Entropy as a Service is a RESTful web service that allows you to generate random data (henceforth referred to as entropy or random) that is truly random—based on quantum-mechanical phenomena.\nGetting Started To start using Qrypt Entropy as a Service, you need to create a Qrypt account, obtain an access token, and submit an HTTP request.\nCreate a free Qrypt account To request entropy from the service, you must first create an account.\n  Navigate to https://portal.qrypt.com and select the option to create a new account.\n  Enter your email address and a strong password, then click the button to create your account.\n  Check your email for the 4-digit account confirmation code and enter it on the website to confirm your account.\n  When prompted, enter your first and last name.\n  Generate an access token An access token is required to submit REST API requests.\n  Navigate to the Tokens page.\n  Assign a name to the token to help you distinguish between different tokens.\n  Select the expiration period. This determines when the token will expire and need to be replaced.\n  Click the “Generate token” button.\n  The generated token will be displayed along with an example of how entropy data can be requested. Copy the token using the “Copy” button and store it in a secure location. Important: This is the only time you will be able to view the access token. Be sure to copy and store it before closing this popup.\n  Save the access token to a secure location. Because your access token is used to make requests for entropy—a budgeted resource—it should be treated as secure data, very much like a password.\n  Submit a request for entropy To get entropy from the service, you must submit an HTTP request to the REST API service, providing the aforementioned access token and specifying the number of 1,024-byte blocks of entropy you would like to receive. You must also specify an access token—which identifies the user account requesting the data—in an HTTP “authorization” header. The data is returned in a JSON-encoded structure containing an array of base64-encoded strings, each of which decodes to a 1,024-byte block of entropy, as well as an integer specifying the number of strings in the array.\nNote: To ensure the privacy of your access token and the entropy data, all calls are made using an encrypted HTTPS connection. Follow these steps in your preferred tool or language of choice to request entropy (see subsequent sections Request and Response for details):\n  Specify your access token and the desired number of kibibytes (1,024 bytes) of entropy in a web request. Use the following URL: https://api-eus.qrypt.com/api/v1/quantum-entropy?size={kib_entropy}\n  Replace {kib_entropy} in the aforementioned URL with an integer indicating the number of kibibytes of entropy to return.\n  Include an HTTP “Accept” header field with a value of “application/json”.\n  Include an HTTP “Authorization” header with a value of “Bearer {access_token}”, where {access_token} is the access token obtained from the Qrypt portal.\n  Submit the HTTP request using the HTTP GET method.\n  If the HTTP request is successful, the JSON-formatted response will contain a structure containing two fields named “random” and “size”. The “random” field contains an array of base64-encoded strings (each of which—when decoded—contains 1,024 bytes of entropy). The “size” field contains the number of elements in the “random” field.\n  The following sections provide more detailed explanations of the request and response.\nRequest The web service consists of one REST API call, which returns the entropy. The following table describes the properties of a valid REST API call.\n HTTP Verb GET   URL  https://api-eus.qrypt.com/api/v1/quantum-entropy?size={kib_entropy} {kib_entropy} is an integer that specifies the number of kibibytes (1,024 bytes) of entropy being requested. The minimum value is 1 and the maximum value is 512. If unspecified, the default value is one (1).    Accept(header) \"application/json\"   Authorization(header)  \"Bearer {qrypt_access_token}\" {qrypt_access_token} is an access token generated in the Qrypt portal.    Response The response from the HTTP request will contain a numeric status code indicating whether or not the request succeeded and, if not, why. If successful, it will also return the entropy.\n Status code Description   200 SuccessEntropy was successfully returned.   400 Bad requestThe request was invalid (i.e., malformed or otherwise unacceptable). Please verify the format of the URL and the specified parameters.   401 UnauthorizedThe access token is either invalid or has expired.   403 Limit reachedThe account associated with the specified access token has already retrieved the maximum allotment of entropy allowed for the current period. Please contact a Qrypt representative to request a change to your limit.   429 Rate Limit reachedThe access token used to pull random has exceeded the maximum number of requests (30) allowed for the designated time interval (10 seconds). Please wait and try again.   500 Internal server errorThe Qrypt service has encountered an internal error. Please contact Qrypt support for further assistance.   503 Not enough supplyQrypt’s supply of entropy is temporarily insufficient to fulfill the request. Please wait and try the request again.   If a success status code of 200 was returned, the response contains a JSON-encoded structure containing an array size (which should match the kib_entropy value specified in the request) and an array of base64-encoded strings which, when decoded, contains 1,024 bytes of entropy.\n JSON Fields Description   random An array of base64-encoded strings. The length of the array is specified in the size field (below). Each string, when decoded, contains a 1,024-byte sequence of entropy.   size The number of base64-encoded strings in the array returned in the random field (above).   "
},
{
	"uri": "https://QryptInc.github.io/eaas/faqs/",
	"title": "Frequently Asked Questions",
	"tags": [],
	"description": "",
	"content": "What should I do with my access token?\nYour access token is the mechanism by which your account will be charged for entropy data, and as such, it should be treated as secure and secret information (much as you would treat a password).\nOnce I receive the EaaS response, how do I obtain entropy from it?\nThe EaaS service response is encoded as a JSON structure. Its “random” property will contain an array of base64-encoded strings. The “size” property specifies the length of the array, which should be the same as the size that was specified in the request (i.e., the number of kibibytes of entropy).\nEach base64-encoded string can be decoded to 1,024 bytes of entropy. When all base64-encoded strings are decoded, the concatenation of all decoded bytes comprises the total requested entropy.\nWhat do I do if I forget my password?\nQrypt does not have access to your password, but you can place a request to change your password.\n  Navigate to the portal at https://portal.qrypt.com/login and click the “Forgot password?” link.\n  Enter the email address associated with your account and click the “Send me the link” button.\n  Check your email for a message with further instructions.\n  How do I change my password?\n  Navigate to the portal at https://portal.qrypt.com/login and login to your account.\n  Click the account icon (top-right corner) and select “Account settings.”\n  Click the “Change password” link.\n  Enter your original password, enter a new password, and click the “Change password” button.\n  How do I request a new access token?\nSee section “Generate an access token” for instructions on how to request a new access token.\nI lost or forgot to save my access token. How can I retrieve it?\nTo increase security, Qrypt only displays access tokens when they are first generated. If you have lost your token, you can contact Qrypt sales support at support@qrypt.com or generate a new one.\nWhat happens if I have exceeded my monthly entropy quota?\nIf a request is made after the monthly entropy quota has been reached, the service request will return an error code of 403. Please contact Qrypt sales support at support@qrypt.com.\nI need more entropy bytes per month than my current quota provides.\nTo increase your quota of entropy bytes you can generate per month, either upgrade from your free account to a paid account or contact Qrypt sales support at support@qrypt.com.\nWhen does my entropy quota reset?\nYour quota is reset monthly on the day of the month on which you opened the account.\nWhat happens if my access token expires?\nAfter an access token expires, any requests for entropy using that token will return an error code of 401. You will need to generate a new token and use it for future entropy requests.\nHow is quantum entropy different from rand, urand, grand, and other pseudorandom number generators?\nThe generation of random and pseudorandom numbers is too large a topic to be covered thoroughly here, but the concepts are quite simple. There exist quantum behaviors that are completely random and unpredictable according to the laws of physics. By using a device called a homodyne laser interferometer—which can detect such quantum behaviors—Qrypt can generate and provide sequences of truly random data.\nHow can I delete my Qrypt account?\nWe do not currently support online cancellation of accounts. Please contact Qrypt Sales Support at support@qrypt.com to delete your account.\nI am receiving an error response code from the Qrypt service. How do I identify the problem?\nThe web service returns a status code with each response. This status code should indicate the cause of the failure. In addition to the standard HTTP error codes, the service may also return a Qrypt-specific error code, as detailed in the following table.\n   Status code Explanation and possible remediation     400 The request was invalid. Verify that the request is using the correct access token and URL, and that the requested entropy size specified in the URL is between 1 and 512.   401 Your token is invalid or has expired. Ensure the access token being used is valid or obtain a new valid token.   403 The request has exceeded your monthly entropy quota.   429 You have exceeded the maximum number of requests (30) for the given time interval (10 seconds) with your access token.   500 The Qrypt server is experiencing issues. Please try again later. If the problem persists, please contact Qrypt Technical Support.   503 The Qrypt entropy supply is low. Please try again later. If the problem persists, please contact Qrypt Technical Support.    "
},
{
	"uri": "https://QryptInc.github.io/",
	"title": "Home",
	"tags": [],
	"description": "",
	"content": " Qrypt Documentation   Developer Focused - Our documentation is written by developers for developers. The goal is to make it as easy as possible for developers to use Qrypt products to secure applications.\nOpen Sourced - We believe that source code and documentation benefit from sharing and collaborative improvement. Qrypt documentation is open-sourced and we invite anybody to submit pull requests to improve it.\nIntegrating with Qrypt Below is a list of the products that Qrypt offers with links to their supporting documentation.\nEntropy as a service - Docs Qrypt Entropy as a Service (EaaS) measures quantum effects and converts those measurements into pure random numbers. EaaS leverages multiple Quantum Random Number Generators (QRNGs) developed by national and international research labs to ensure the highest quality random.\nQDARA - Quantum data at rest algorithm - Docs Our quantum secure data-at-rest command line tool is powered by our patented BLAST algorithm, which leverages quantum random number generation from our Entropy as a Service to produce perfectly random one-time pads. Alice can quickly and easily encrypt sensitive files with quantum random generated one-time pads. Bob must have the same pad in order to decrypt the data to read the files, ensuring important information is kept secret.\nQrypt Security - Docs Qrypt Security includes client library SDKs, cloud-based REST services, command line clients and guidance to help integrate post-quantum and everlasting security into your applications and services. You can add security features to your applications without being an expert in post-quantum cryptography.\n"
},
{
	"uri": "https://QryptInc.github.io/data_at_rest/",
	"title": "Data at Rest",
	"tags": [],
	"description": "",
	"content": "Getting Started with the Data at Rest Client In the following guide, we will help you get started with encrypting your data with a One Time Pad using the Qrypt Data at Rest Algorithm (QDARA) client. This guide will show you how to encrypt a file containing the message “Hello World”. For more detailed instruction on using the command line interface, please reference our QDARA Reference Guide.\nFor decryption, there are two use cases:\n  A user can encrypt and decrypt files on a single device.\n  Alice physically transfers her quantum random and cache file to Bob. Alice encrypts data and sends it to Bob over the internet, and Bob decrypts.\n  Before you get started Follow the instructions at https://www.qrypt.com/docs/eaas to\n  Create a free Qrypt account\n  Generate an access token.\n  Download the QDARA client for the OS you are running at https://portal.qrypt.com/ into a folder of your choice. To verify you downloaded the correct .zip file, you can check that the SHA256 Hash matches the one listed on the Download page.\nFor MacOS and Linux, to compute the hash, run\n shasum -a 256 qdaracl-\u0026lt;version-os\u0026gt;.zip\n Note that to verify the zip file for MacOS, you must choose to “Save file” because MacOS will automatically extract the file if you choose to open it.\nFor Windows, to compute the hash, run\ncertUtil -hashfile qdaracl-.zip SHA256(Optional) Add installation folder to your PATH environment variable For MacOS and Linux, edit your .bashrc or .zshrc file and add the line\n export PATH=$PATH:\u0026lt;insert installation folder path here\u0026gt;\n For Windows, open the start menu and search for “Edit environment variables”. Click on the “Path” variable and click “edit.” Add a new path for the folder containing the QDARA client.\nClose your terminal, and test that you can run the tool by running\n qdaracl -h\n Download Quantum Random for your Key You will need your access token generated from the Qrypt portal. To download 2 KB of random, run\n qdaracl download -t \u0026lt;insert token here\u0026gt; -s 2 -o key.qrand\n This will store 2 KB of quantum random into key.qrand. Note that you need at least as much random as the size of your plaintext file, and a minimum of 2 KB of random to encrypt any file.\nInitiate the client encryption tool  qdaracl init -i key.qrand -o my_cache.qcache\n This will generate a cache file that stores metadata about how much of the random has been used. Note that it is the user’s responsibility to store the cache file securely.\nEncrypt your data Create a plaintext file.\n echo \u0026quot;Hello World\u0026quot; \u0026gt; plaintext.txt\n Encrypt the file.\n qdaracl encrypt -c my_cache.qcache -i plaintext.txt -o ciphertext.qdara\n Decrypt your data When you are ready to decrypt, you can simply run\n qdaracl decrypt -c my_cache.qcache -i ciphertext.qdara -o new_plaintext.txt\n Note that if you are a user on a different device, you must physically obtain my_cache.qcache and key.qrand from the original encryptor.\nEncrypt more files To encrypt larger size files, you may need to download more random! Here is a table of the minimum amount of random you need for a given plaintext size.\n   Plaintext Size Minimum Random Size in Cache     1 KB 5 KB   10 KB 27 KB   100 KB 218 KB   1 MB 2103 KB (\u0026gt; 2 MB)   2 MB 4173 KB (\u0026gt; 4 MB)   4 MB 8301 KB (\u0026gt;8 MB)    "
},
{
	"uri": "https://QryptInc.github.io/sdk/concepts/otp/",
	"title": "One-Time Pad (OTP)",
	"tags": [],
	"description": "",
	"content": "Our Technology Qrypt offers solutions to make One-Time Pads, the only known information theoretically secure symmetric encryption algorithm, finally practical in industry.\nWhat is classical cryptographic security? A cryptographic algorithm is considered secure, when the algorithm has been around for several years, and there is still no known method to “break” the algorithm with a classical computer.\nFor example, the widely used RSA algorithm has been around since 1977 with no significant progress made on a method to break it with a classical computer.\nWhat is post-quantum security? With the age of quantum computers being on the horizon, researchers have also explored methods to break cryptography using a quantum computer. Post-quantum cryptography means that after years of research, there is still no known method to “break” the cryptography, even given a quantum computer.\nFor example, RSA, would not satisfy post-quantum security because Shor’s algorithm, an attack using a quantum computer, was discovered to break RSA in 1994. On the other hand, AES-256 is considered post-quantum because no quantum attacks have been discovered since its publication in 1998.\n One-Time Pads   A One-Time Pad cipher is when a randomly chosen key, the same length of the plaintext, is XORed with the plaintext to produce the ciphertext. If the key is truly chosen randomly, all plaintexts of the given size are equally likely to have produced the ciphertext.\nWhat is information theoretic security? One-Time Pads have been mathematically proven to be information theoretically secure, meaning there is a mathematical proof that there exist no attacks (even with a computationally unbounded adversary) that can break a One-Time Pad. On the other hand, it is possible for a “post-quantum” algorithm to be broken, if in the future, someone were to discover a quantum attack on the algorithm.\nWhy isn’t everyone using One-Time Pads? One-Time Pads are only secure if the key is truly random, and only recent quantum technology has made truly random keys possible.\nIn addition, One-Time Pads are only secure if the keys are never reused. This means we need to share a newly randomly generated key, which is the same size of the plaintext, every time we want to send a new plaintext message. This reduces the security of the One-Time Pad down to the security of the key exchange algorithm.\nQrypt Data at Rest Algorithm – QDARA To encrypt data at rest, we don’t need to worry about key exchange. There will either be a single party encrypting data on their device, or multiple parties who have physically distributed a truly random string X. The use case for the QDARA client is described in Section 5.1 of the whitepaper.\nBLAST The Bounded Linearly Accessible String (BLAST) extractor (Yevgeniy Dodis and Kevin Yeo, 2021) is a cryptographic primitive that offers a stateless solution for multiple parties to extract a One-Time Pad given a truly random string X.\nGiven a pool of truly random numbers X, BLAST takes a seed S as input, and outputs a One-Time Pad R. The extracted R is indistinguishable from a randomly generated R.\n See the whitepaper for more details about BLAST and a proof of its indistinguishability from random. Note that the whitepaper refers to BLAST as a doubly affine extractor.\nEncryption and Decryption Each encryption has three inputs: a plaintext, a key, and either an initialization vector (IV) or a seed. Decryption requires a ciphertext, the same key, and the same IV or seed to decrypt. The procedures are described in more detail in the Init, Encrypt, and Decrypt methods below.\nInit (Encryptor):\n Obtain quantum random X from Qrypt and store in qrand files. Generate a seed S_AES on your machine using OpenSSL. Extract an AES-256 key and IV pair ¬K using BLAST with the seed S_AES and quantum random X and store them in the qcache file. Physically transfer qrand files and the qcache file to the decryptor.  Init (Decryptor)\n Physically obtain qrand files and qcache file from the encryptor.  Note: The user is responsible for storing the qrand and qcache files securely.\n Encrypt  Generate a seed SOTP and an AES-256 key and IV pair K0 on your machine from OpenSSL. Extract the One-Time Pad using the BLAST with the seed SOTP and quantum random X. Compute the ciphertext by XORing the One-Time Pad with the plaintext. Encrypt the ciphertext once more with AES-256 OCB mode to provide authentication with the seed SOTP as associated data. Encrypt SOTP and K0 using AES-256 OCB mode with the key and IV pair K in your cache file and append it to the final ciphertext.   Decrypt  Decrypt the seed SOTP and AES-256 key and IV pair K0 using AES-256 OCB mode with the key and IV pair K in your cache file. Decrypt the ciphertext using AES-256 OCB mode with the key and IV pair K in your cache file. Extract the One-Time Pad using BLAST with the seed SOTP and quantum random X. Compute the final plaintext by XORing the One-Time Pad with the ciphertext.   Why use BLAST instead of using X directly? Having a stateless method of determining the One-Time pad from X makes it much easier for parties of 3 or more to communicate using the same random pool X. Instead of requiring all parties to keep track of an index which can easily get out of sync, it is much simpler to use a new seed for each encryption. Using BLAST also ensures that the One-Time Pad is never stored in the clear and offers additional security in case chunks of X are stolen.\nAre we reusing One-Time Pads? We keep track of the percentage of X we have used in the cache file. Once the usage exceeds a user-configurable percentage (default set to 50%) of X, the user can no longer encrypt with X unless they use the –force flag. The percentage corresponds to 1-β in the whitepaper.\nAlthough it is possible that BLAST uses the same bit twice in different encryptions, the whitepaper proves that the extracted One-Time Pad is indistinguishable from a purely random One-Time Pad as long as the total length of the One-Time Pads used is bounded by (1-β)|X|.\nWhere are the seeds stored? The seeds are encrypted with AES-256, and the encrypted seed is appended to the ciphertext. The AES key and IV are stored in the cache file.\nWhat level of security does QDARA offer? Our QDARA client offers post-quantum security. An adversary can only gain secret information if they have access to both the full random string X (by breaking TLS when the user downloads X) and the seed S (by breaking AES). Since AES is a post-quantum algorithm, the client achieves post-quantum security.\nDoes QDARA provide authentication? Yes, after the ciphertext is encrypted with the One-Time Pad, we use AES-256 OCB mode to provide authentication with the seed as associated data. If the ciphertext is tampered with, the AEAD authentication will fail.\nHow much random do I need for an encryption? This depends on the user-configurable percentage α (default set to 50%), which is the maximum amount of random you can use from a cache. There are three constraints you must fulfill to encrypt a file of size m:\n You must have at least m bytes available to use out of the α|X| total available bytes. If you wish to encrypt a file of size m, your cache must have a total of at least bytes in order to sample the necessary size using BLAST *see whitepaper for details, note we set ϵ=2-64). Note that this refers to the total number of random bytes and is independent of the number of available random bytes. Regardless of m, you must have at least enough random to call the BLAST extractor to generate an AES key and IV (44 bytes). You can obtain this value by plugging in m=44 to the above equation.  For example, to encrypt a file of 5 KB = 5120 bytes, with our depletion parameter set to α=0.5, we must:\n Have at least 5120 random bytes available. Have at least 14,890 total random bytes (obtained from plugging in m = 5120 into the equation). Since we are encrypting more than 44 bytes, this requirement is redundant.  Here is a table of minimum cache sizes for reference.\n   Plaintext Size Minimum Cache Size     1 KB 5 KB   10 KB 27 KB   100 KB 218 KB   1 MB 2103 KB (\u0026gt; 2 MB)   2 MB 4173 KB (\u0026gt; 4 MB)   4 MB 8301 KB (\u0026gt; 8 MB)    How long does it take to encrypt? For a random pool size of 10 MB, we have the following performance numbers which were collected on a MacBook (15-inch Mid 2015).\n   Plaintext Size Time (seconds)     1 KB 0.06   10 KB 0.25   100 KB 5.80   1 MB 203.12   2 MB 600.56   4 MB 1673.12    Qrypt Key Exchange Solution – BLAST Qrypt offers a novel key exchange solution, (Section 5.2 of the whitepaper) which offers everlasting security.\nHow secure are key exchange algorithms?   Algorithms Level of Security Drawbacks   RSA, Diffie Hellman, ECDH Classical security   Not post-quantum     Classic McEliece, CRYSTALS-KYBER, FrodoKEM Post-quantum security   Not provably secure Slow/inefficient   Quantum Key Distribution (QKD): BB84, E91, B92 Information theoretically secure (dependent on accuracy of hardware)   Costly Range of communication is limited Tolerance for error in cryptographic security, however, is many order of magnitude smaller than in most physical engineering scenarios making it very difficult to validate     Qrypt solution Everlasting security (explained below)   Assumes the user has a secure channel with a user-configurable value g out of t Qrypt servers     What is everlasting security? A protocol which achieves everlasting security guarantees that an encryption is information theoretically secure, given that the initial key exchange of the seed S is not broken within a time T which we can choose (i.e. a week). This means that a week after the two parties exchange an initial seed S, even a computationally unbounded adversary (with access to both classical and quantum computers) cannot break the encryption.\nLevels of Security   Classical security that is vulnerable to quantum computers (i.e. RSA, ECDH)\n  Post quantum security that has no known algorithm that quantum computers could run to break (i.e. FrodoKEM, Crystals-Kyber)\n  For levels 1 and 2, to break the encryption, an adversary would need to:\n Harvest data between Alice and Bob Break the key exchange   3a) Everlasting security which is provably secure against an unbounded adversary after phase 1 (while the server is still accepting decryption requests), where:\n the seed key exchange has level 1 security in phase 1 we assume g out of T servers have secure, authenticated channels with the client (where these channels use TLS)  3b) Everlasting security which is provably secure against an unbounded adversary after phase 1 (while the server is still accepting decryption requests), where:\n the seed key exchange has level 2 security in phase 1 we assume g out of T servers have secure, authenticated channels with the client (where these channels use TLS)  3c) Everlasting security which is provably secure against an unbounded adversary after phase 1 (while the server is still accepting decryption requests), where:\n the seed has level 2 security in phase 1 we assume g out of T servers have secure, authenticated channels with the client (where these channels use post-quantum TLS)   For levels 3a, 3b, and 3c, to break the encryption, an adversary would need to:\n Harvest data between Alice and Bob Harvest data from greater than T-g server links to Alice or Bob Break the key exchange of the seed Break the protocol for downloading random  Information theoretic security that is provably secure against an unbounded adversary (which Qrypt only has the capability of doing with physical transfer of key material)  What levels of security does Qrypt offer? Our SDK offers:\n Classical SKU for QDEA at level 1 Post-quantum SKU for QDEA, QDARA at level 2 Digital QKD (everlasting security SKU) at levels 3a and 3b Note that for an adversary to break a SKU, they must break the protocol or primitive in all 3 columns below.    Level Qrypt offering Data Harvesting Key exchange for seeds/symmetric keys Protocol for downloading random   Level 1 (classical) QDEA classical SKU Adversary needs to harvest data from only one network transmission ECDH (classical) N/A   Level 2 (post-quantum) QDARA, QDEA post-quantum sku Adversary needs to harvest data from only one network transmission Lattice crypto (PQC) N/A   Level 3a (everlasting security) Digital QKD with user-supplied channel Adversary needs to harvest data from:  More than T-g transmissions from QDEA servers Key exchange of seed   ECDH (classical) Classical TLS   Level 3b (everlasting security) Digital QKD sample Adversary needs to harvest data from:  More than T-g transmissions from QDEA servers Key exchange of seed   Lattice crypto (PQC) Classical TLS   Level 3c (everlasting security) -- Adversary needs to harvest data from:  More than T-g transmissions from QDEA servers Key exchange of seed   Lattice crypto (PQC) Post-quantum TLS   Level 4 (information theoretic security) -- Adversary needs to steal physical devices Physical transfer N/A   "
},
{
	"uri": "https://QryptInc.github.io/sdk/quickstarts/getting-started/",
	"title": "Getting started",
	"tags": [],
	"description": "",
	"content": "The Qrypt Security SDK is available as a NuGet package targeting .NET Standard 2.0 and .NET 5.\nCurrently the NuGet packages are available via download from our portal site only. We are researching moving distribution to NuGet.org.\nSetup a local NuGet Feed Download an appropriate Qrypt SDK package from the Qrypt Portal and place it in a folder you would like to use as your local NuGet feed.\nVisual Studio Visual Studio Code  On the Tools menu, select Options \u0026gt; NuGet Package Manager \u0026gt; Package Sources. Select the green plus in the upper-right corner and enter the name and source URL below.\nName\nqrypt-security\nSource\nUse the browse button to select the folder you placed the NuGet package in.\n Add a nuget.config file to your project, in the same folder as your .csproj or .sln file\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;packageSources\u0026gt; \u0026lt;clear /\u0026gt; \u0026lt;add key=\u0026quot;qrypt-sdk\u0026quot; value=\u0026quot;folder you placed NuGet package in.\u0026quot; /\u0026gt; \u0026lt;/packageSources\u0026gt; \u0026lt;/configuration\u0026gt;  Example\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;packageSources\u0026gt; \u0026lt;clear /\u0026gt; \u0026lt;add key=\u0026quot;qrypt-sdk\u0026quot; value=\u0026quot;c:\\packages\u0026quot; /\u0026gt; \u0026lt;/packageSources\u0026gt; \u0026lt;/configuration\u0026gt;     "
},
{
	"uri": "https://QryptInc.github.io/sdk/overview/",
	"title": "Overview",
	"tags": [],
	"description": "",
	"content": "What is Qrypt Security? Qrypt Security includes client library SDKs, cloud-based REST services, command line clients and guidance to help integrate post-quantum and everlasting security into your applications and services. You can add security features to your applications without being an expert in post-quantum cryptography.\nSpecifically, we currently offer features for:\n post-quantum safe file encryption secure end-to-end messaging one-time pads (late 4th Quarter, 2021)  Our Quantum Enhanced Classical product line brings value to you by giving you quantum random on your computers, encrypting files with better AES keys generated from quantum random, and better messaging that you\u0026rsquo;re using now because the keys are created from quantum random. But our Everlasting Security product line gives you those things, as well as a seamless upgrade path to Post Quantum security and beyond, when you\u0026rsquo;re ready.\n The Everlasting Security product line will be available late 4th Quarter, 2021.\n "
},
{
	"uri": "https://QryptInc.github.io/sdk/quickstarts/chat/",
	"title": "Quickstart: Add Secure Messaging to your App",
	"tags": [],
	"description": "",
	"content": "Get started with the Qrypt Security SDK by building a simple secure messaging app.\nWe will use Azure Communication Services as our messaging back-bone for this app. However, you can use the messaging infrastructure that makes sense for you. The Qrypt Security SDK can layer into a wide variety of messaging services from Azure Communication Services to SendBird to RabbitMQ and many more.\nTo learn more about Secure Messaging concepts, visit the secure messaging conceptual documentation.\nSample Code Find the finalized code for this quickstart on GitHub.\nPrerequisites Before you get started, make sure to:\n Install .NET 5. Install Visual Studio Code. Create an Azure account with an active subscription. For details, see Create an account for free. Create an Azure Communication Services resource. For details, see Create an Azure Communication Services resource. You\u0026rsquo;ll need to record your resource endpoint and access key for this quickstart.  This Quickstart has been tested using:\n .NET 5 Visual Studio Code v1.61.2 Qrypt Security SDK - post_quantum v0.3.4  Setting up Gettting started\nFollow the instructions in Getting Started to locally stage the Qrypt Security post-quantum SDK NuGet package.\nSetup Environment Variables\nTo make this Quickstart as simple as possible, we are using environment variables to store our state. Two environment variables must be setup before hand. The others will be dynamically created.\n   Environment Variable Description     COMMUNICATION_SERVICES_ENDPOINT Set this to your Azure Communication Services endpoint value for the Azure Communication Services resource you created in Prerequisites above.   COMMUNICATION_SERVICES_ACCESS_KEY Set this to your Azure Communication Services access key for the Azure Communication Services resource you created in Prerequisites above.    Download the code\nFind the finalized code for this quickstart on GitHub.\nClone the repository and open the add-chat folder in Visual Studio Code.\nBuild the code To build the code in Visual Studio Code:\nCtrl-Shift-b | build - ChatQuickStart\nRun the code Run as Alice first. Navigate to the debug tab in Visual Studio Code and select from the debug drop-down:\nAlice - ChatQuickstart\nThen run as Bob. Select from the debug drop-down:\nBob - ChatQuickstart\nThe terminal in Visual Studio Code will display:\nhello world  Understanding the code Environment Variables To make this Quickstart as simple as possible, we are using environment variables to store our state. Two environment variables must be setup before hand. The others will be dynamically created.\n   Environment Variable Description     COMMUNICATION_SERVICES_ENDPOINT Set this to your Azure Communication Services endpoint value.   COMMUNICATION_SERVICES_ACCESS_KEY Set this to your Azure Communication Services access key.   COMMUNICATION_SERVICES_IDENTITY_ALICE This will be dynamically created by the Quickstart for each run and will be set to Alice\u0026rsquo;s Azure Communcation Services identity id.   COMMUNICATION_SERVICES_IDENTITY_BOB This will be dynamically created by the Quickstart for each run and will be set to Bob\u0026rsquo;s Azure Communcation Services identity id.   COMMUNICATION_SERVICES_CHAT_THREAD This will be dynamically created by the Quickstart for each run and will be set to the Azure Communcation Services chat thread id for the chat between Alice and Bob.    The project file x64 Builds Only\nThe Qrypt Security SDK is available for x64 builds only. We can see that this is specifed in the project file here:\n\u0026lt;Platforms\u0026gt;x64\u0026lt;/Platforms\u0026gt;  NuGet Packages\nWe can see the appropriate NuGet references have been added for Azure Communication Services and the Qrypt Security post-quantum SDK.\n\u0026lt;ItemGroup\u0026gt; \u0026lt;PackageReference Include=\u0026quot;Azure.Communication.Chat\u0026quot; Version=\u0026quot;1.0.1\u0026quot; /\u0026gt; \u0026lt;PackageReference Include=\u0026quot;Azure.Communication.Identity\u0026quot; Version=\u0026quot;1.0.1\u0026quot; /\u0026gt; \u0026lt;PackageReference Include=\u0026quot;QryptSecurity_post_quantum\u0026quot; Version=\u0026quot;0.3.4\u0026quot; /\u0026gt; \u0026lt;/ItemGroup\u0026gt;  Building the code A Visual Studio Code task has been setup in:\n.vscode\\tasks.json\nfor this purpose.\nRunning the code with command Line Arguments Either alice or bob must be specified as command line arguments. The code will follow a specific path for sending or receiving based on the argument specified. A complete test run of the Quickstart entails:\n Running as alice to send a secure message to bob. Running as bob to receive the secure message from alice.     Command Line Argument Description     alice Run as alice first. This will send a secure \u0026ldquo;hello world\u0026rdquo; message to bob.   bob Run as bob second. This will receive the secure \u0026ldquo;hello world\u0026rdquo; message from alice.    Visual Studio Code launch targets have been setup in\n.vscode\\launch.json\nfor this purpose.\nNext steps In this quickstart you learned how to:\n Create a messaging chat client Create a chat thread with two users Securely send a message to the thread by layering in calls to the Qrypt Security SDK Securely receive messages from a thread by layering in calls to the Qrypt Security SDK  You may also want to:\n Learn about secure messaging concepts Familiarize yourself with the Qrypt Security SDK  "
},
{
	"uri": "https://QryptInc.github.io/sdk/",
	"title": "Qrypt Security",
	"tags": [],
	"description": "",
	"content": "Quantum Entropy and Quantum Secure Cryptography for all Qrypt Security includes client library SDKs, cloud-based REST services, command line clients and guidance to help integrate post-quantum and everlasting security into your applications and services.\nBuild post-quantum safe services and apps at scale.\nEnterprise clients and developers can use Qrypt’s cryptography as the encryption for their own applications and services to secure data-at-rest and data-in-motion.​\n"
},
{
	"uri": "https://QryptInc.github.io/sdk/quickstarts/",
	"title": "Quickstarts",
	"tags": [],
	"description": "",
	"content": "Use the Quickstarts to get started with the the Qrypt Security SDK.\n"
},
{
	"uri": "https://QryptInc.github.io/sdk/concepts/",
	"title": "Concepts",
	"tags": [],
	"description": "",
	"content": "Use the pages in this section to dig deeper into the post-quantum and everlasting security technologies Qrypt has to offer.\n"
},
{
	"uri": "https://QryptInc.github.io/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://QryptInc.github.io/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]